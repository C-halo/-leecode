<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

### 自己做法：

```js
var isValid = function (s) {
    const op = []
    for (str of s) {
        if (str === '(' || str === '{' || str === '[') op.push(str)
        if (str === ')' && op.pop() != '(' ||
            str === ']' && op.pop() != '[' ||
            str === '}' && op.pop() != '{') {
            return false
        }
    }
    return !op.length
};
```

### 官方做法：

```js
var isValid = function (s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([//构建哈希表  Map方法
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s) {
        if (pairs.has(ch)) { //是否包含该键   即判断是否是右括号
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;//栈为空，或者栈顶不匹配自己返回false
            }
            stk.pop();//出栈
        }
        else {//若是左括号则直接入栈
            stk.push(ch);
        }
    };
    return !stk.length;
};
```



## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：

1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列

```js
var validateStackSequences = function (pushed, popped) {
    const stack = []
    let j = 0
    for (x of pushed) {
        stack.push(x)//先进栈，再判断    JS中没有peek()方法
        while (stack.length>0 && stack[stack.length-1] === popped[j]) {//检查栈顶元素是否和pop的当前元素相等
            stack.pop()
            j++ //poped栈后移
        }
    }
    return stack.length===0 //判断stack是否清空
};
```



## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者
- 它可以被写作 `(A)`，其中 `A` 是有效字符串。

给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

**示例 ：**

```
输入："()))(("
输出：4
```

```js
var minAddToMakeValid = function (s) {
    const stake = []
    for (char of s) {
        //只有当栈顶为左括号，当前为右括号才弹出
        if (stake.length && stake[stake.length - 1] === '(' && char === ')') {
            stake.pop()
        }else{//其他情况全部压入栈中
            stake.push(char)
        }
    }
    return stake.length
};
```



## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)

编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。

示例：

```
输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

提示：

```
调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
每个测试用例最多可以调用  10000 次 StockSpanner.next。
在所有测试用例中，最多调用 150000 次 StockSpanner.next。
此问题的总时间限制减少了 50%。
```

### 自己做法（运行时间久，每次都要从当前位置向前一直判断）

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    let spanner = 1
    let n = this.stake.length
    while (this.stake[n - spanner] <= price) {
        spanner++
    }
    this.stake.push(price)
    return spanner
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = new StockSpanner()
 * var param_1 = obj.next(price)
 */
```

### 单调栈   解题思路

正如题意，我们要求当前元素之前，比自己小（可以相等）的元素个数，并且元素个数包括本身，那么我们最后的结果应该还要加1.

于是按题意，我们采用跨度法，举个例子，对于例子6，1，2，3，4，9，从后往前逆推一下，当我们新插入9的时候，如果发现前一位的4比9小，那么是否说明比9小的数量就等于比4小的数量加1？然而这是错的，因为首位的6比9小，却比4大，因此截止数字的4时候，比4小的数量中并不包含6与9的对比。

因此，我们还要跳到 6 的位置再去计算小于等于自己的元素。

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    const stake = this.stake
    const spanner = this.spanner
    if(!stake.length){//判断特殊情况
        stake.push(price)
        spanner.push(1)
        return 1
    }
    let cnt =0;//当前跨度数量
    let idx = stake.length-1;//比较的位置
    while(stake.length>0 && price>=stake[idx]){
        cnt += spanner[idx]//计数+当前跨度
        idx -= spanner[idx]//移动到比idx大的位置
    }
    cnt++//最后加上自身
    stake.push(price)
    spanner.push(cnt)
    return cnt
};
```





## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

### 暴力法   O(m*n)

```js
var dailyTemperatures = function (temperatures) {
    const n = temperatures.length
    const res = new Array(n).fill(0)
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            if (temperatures[i] < temperatures[j]) {
                res[i] = j - i
                break
            }
        }
    }
    return res
};
```

### 单调栈

*stack*=[2(75),3(71),4(69)]

当 i=5时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:=5-4 和 ans[3]:=5-3，将 5进栈。

stack=[2(75),5(72)]

ans=[1,1,0,2,1,0,0,0]



```js
var dailyTemperatures = function (temperatures) {
    const stake = [] //用于存储还未得到结果的下标
    const n = temperatures.length
    const ans = new Array(n).fill(0)
    for (let i = 0; i < n; i++) {
        let t = temperatures[i]
        while (stake.length && temperatures[stake[stake.length - 1]] < t) {//stake栈顶下标元素于当前t的大小
            let pre = stake.pop()//得到结果的下标出栈
            ans[pre] = i - pre
        }
        stake.push(i)//当前下标入栈
    }
    return ans
};
```



## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

### 解题思路

既然是求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。

比如 `[2,4,1,2]` ,以`1` 为最小数。能构成的数组数为 `(2+1)*(1+1)` ，`2` 表示 `1 `左面有两个比它大的数，`1` 表示 `1` 右面有一个比它大的数。

用单调栈求出 `A[i]` 对应的左右最近比 `A[i]` 小的数，记索引为 `prev,next，A[i] `为最小数能形成的数组为

```
(i-prev[i])*(next[i]-i)
```

这里为什么没有加 `1` 了呢，因为 `prev[i]`已经是比 `A[i]` 小的数了，能和 `A[i]` 形成数组的都是比 `A[i]` 大的数。

### 补充

注释已经足够详细，还是补充一下，我参考了大佬的解题代码，只不过我是直接求出来了以当前 `A[i]` 为最小值的子数组左右两边 大于或等于当前值的个数。这样后续求和直接相乘即可。（不过这里要**强调一下**，如果左边设置大于等于了，右边就只能是大于了，不然会重复计算相等的值）

开始有点看不懂大佬为啥左边初始化为 `-1`，右边初始化为 `A.length` 。假如我们遇到了这种情况，左边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时左边个数应该为 `i+1`（从 0 开始计数嘛），那么这部分大佬设为 `-1` 就很巧妙了，问题也就自然明白啦，个人感觉自己写的还是比较好理解一点，不然直接弄一个 `-1` ，第一次用单调栈，还是不太熟...

那么对于右边初始化为 `A.length` ，也是同理啦，当右边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时右边个数应该为 `A.length-i`（不用`+1`的原因是从0计数），那么这部分大佬设为 `A.length` 就很巧妙了，依旧清晰明了。

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubarrayMins = function(A) {
  let mod = 1e9+7
  // 维护一个栈
  let stack = []
  // 求以A[i]为最小值的子数组左边大于或等于自己的个数
  let prev = []
  for(let i=0;i<A.length;i++){
    while(stack.length && A[stack[stack.length-1]] >= A[i]) stack.pop()
    // 如果栈为空，即左边都比自己大，则返回i+1，否则返回i-栈顶元素（即保存的下标值）
    prev[i] = stack.length ? i - stack[stack.length-1] : i+1
    stack.push(i)
  }
  stack = []
  // 求以A[i]为最小值的子数组右边大于自己的个数（没有等号是因为不会重复计算相等的值）
  let nextv = []
  for(let i=A.length-1;i>=0;i--){
    while(stack.length && A[stack[stack.length-1]] > A[i]) stack.pop()
    // 如果栈为空，即右边都比自己大，则返回A.length-i，否则返回栈顶元素（即保存的下标值）-i
    nextv[i] = stack.length? stack[stack.length-1] - i : A.length-i
    stack.push(i)
  }
  let sum = 0
  for(let i=0;i<A.length;i++){
    // 以A[i] 为最小值的子数组的组合共有prev[i]*nextv[i]种情况，那么和的话乘以A[i]累加即可
    sum += (prev[i]*nextv[i]*A[i])
    // 按题意，进行取模运算
    sum %= mod
  }
  return sum
};
```



## [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

**示例 2：**

```
输入：s = "(u(love)i)"
输出："iloveu"
解释：先反转子字符串 "love" ，然后反转整个字符串。
```

### 做法一

```js
var reverseParentheses = function(s) {
    const stk = [];
    let str = '';
    for (const ch of s) {
        if (ch === '(') {
            stk.push(str);//遇到左括号把上次保存字符串的入栈
            str = '';
        } else if (ch === ')') {
            str = str.split("").reverse().join("");//转为数组 调用reverse方法再转为string
            str = stk[stk.length - 1] + str;//返回给上一层
            stk.pop();//栈顶字符串出栈
        } else {
            str += ch;
        }
    }
    return str;
};
```

O(n^2)

### 做法二 

<img src="%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/1.png" alt="img" style="zoom: 67%;" />

```js
var reverseParentheses = function(s) {
    const n = s.length;
    const pair = new Array(n).fill(0);
    const stack = [];
    for (let i = 0; i < n; i++) {//记录左右括号的匹配位置
        if (s[i] === '(') {
            stack.push(i);//用栈记录左括号位置
        } else if (s[i] == ')') {
            const j = stack.pop();//遇到右括号
            pair[i] = j;//右括号对应的左括号位置
            pair[j] = i;//左括号对应的右括号位置
        }
    }

    const sb = [];
    let index = 0, step = 1;
    while (index < n) {
        if (s[index] === '(' || s[index] === ')') {
            index = pair[index];//记录要跳转的位置
            step = -step;//判断方向
        } else {
            sb.push(s[index]);//加入char
        }
        index += step;
    }
    return sb.join('');
};
```



## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」

示例 1：

```
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
```

### 解题思路

一开始我是想着只要对应括号匹配就好了，将多余的右括号删掉，但是这个样例 `))((` 不可能过的，因为左括号也可以不匹配呀。于是我想着将括号对应字符串索引存起来，起初我们可以将不匹配的右括号还是按原来方法删掉就好了，匹配一个就删掉一个对应左括号的索引值，最后多出来的索引值全删掉就好了，这样就不会出现左括号还余留的情况。

这里提示一下：不要用 `splice`去删除指定下标的元素，`splice`会改变原数组长度，而你原本存的下标是基于原数组的。 `delete`方法不会改变数组长度，但删除的那个位置会变成`'undefined'`，所以我们用`fliter`方法过滤一遍出有效值 `arr=arr.filter(item=>item)`

最后通过 `res.join('')` 方法，将数组转换成我们最后要的字符串即可。

```js
var minRemoveToMakeValid = function (s) {
    let res = [...s]//转化为数组才能使用相关的删除方法
    const stake = []//用来保存未被匹配的括号位置
    let n = res.length
    for (i = 0; i < n; i++) {
        let char = s[i]
        if (char === '(') {
            stake.push(i)
        }
        if (char === ')') {
            if (stake.length) {
                stake.pop()//说明匹配到一对括号
            } else {//splice会改变原数组长度,delete会将该位置置为undefined,最后filter即可
                delete (res[i])
            }
        }
    }
    while(stake.length){
        delete (res[stake.pop()])//删除多余的左括号位置
    }
    res = res.filter(item=>item) //去除undefined
    return res.join('')
};
```





## 队列

## [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

示例：

```
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

```js
var RecentCounter = function () {
    this.line = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
    count = 0
    line = this.line
    for (num of line) {
        if (num >= t - 3000) count++
    }
    line.push(t)
    return count + 1
};
```

=======
## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

### 自己做法：

```js
var isValid = function (s) {
    const op = []
    for (str of s) {
        if (str === '(' || str === '{' || str === '[') op.push(str)
        if (str === ')' && op.pop() != '(' ||
            str === ']' && op.pop() != '[' ||
            str === '}' && op.pop() != '{') {
            return false
        }
    }
    return !op.length
};
```

### 官方做法：

```js
var isValid = function (s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([//构建哈希表  Map方法
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s) {
        if (pairs.has(ch)) { //是否包含该键   即判断是否是右括号
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;//栈为空，或者栈顶不匹配自己返回false
            }
            stk.pop();//出栈
        }
        else {//若是左括号则直接入栈
            stk.push(ch);
        }
    };
    return !stk.length;
};
```



## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：

1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列

```js
var validateStackSequences = function (pushed, popped) {
    const stack = []
    let j = 0
    for (x of pushed) {
        stack.push(x)//先进栈，再判断    JS中没有peek()方法
        while (stack.length>0 && stack[stack.length-1] === popped[j]) {//检查栈顶元素是否和pop的当前元素相等
            stack.pop()
            j++ //poped栈后移
        }
    }
    return stack.length===0 //判断stack是否清空
};
```



## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者
- 它可以被写作 `(A)`，其中 `A` 是有效字符串。

给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

**示例 ：**

```
输入："()))(("
输出：4
```

```js
var minAddToMakeValid = function (s) {
    const stake = []
    for (char of s) {
        //只有当栈顶为左括号，当前为右括号才弹出
        if (stake.length && stake[stake.length - 1] === '(' && char === ')') {
            stake.pop()
        }else{//其他情况全部压入栈中
            stake.push(char)
        }
    }
    return stake.length
};
```



## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)

编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。

示例：

```
输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

提示：

```
调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
每个测试用例最多可以调用  10000 次 StockSpanner.next。
在所有测试用例中，最多调用 150000 次 StockSpanner.next。
此问题的总时间限制减少了 50%。
```

### 自己做法（运行时间久，每次都要从当前位置向前一直判断）

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    let spanner = 1
    let n = this.stake.length
    while (this.stake[n - spanner] <= price) {
        spanner++
    }
    this.stake.push(price)
    return spanner
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = new StockSpanner()
 * var param_1 = obj.next(price)
 */
```

### 单调栈   解题思路

正如题意，我们要求当前元素之前，比自己小（可以相等）的元素个数，并且元素个数包括本身，那么我们最后的结果应该还要加1.

于是按题意，我们采用跨度法，举个例子，对于例子6，1，2，3，4，9，从后往前逆推一下，当我们新插入9的时候，如果发现前一位的4比9小，那么是否说明比9小的数量就等于比4小的数量加1？然而这是错的，因为首位的6比9小，却比4大，因此截止数字的4时候，比4小的数量中并不包含6与9的对比。

因此，我们还要跳到 6 的位置再去计算小于等于自己的元素。

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    const stake = this.stake
    const spanner = this.spanner
    if(!stake.length){//判断特殊情况
        stake.push(price)
        spanner.push(1)
        return 1
    }
    let cnt =0;//当前跨度数量
    let idx = stake.length-1;//比较的位置
    while(stake.length>0 && price>=stake[idx]){
        cnt += spanner[idx]//计数+当前跨度
        idx -= spanner[idx]//移动到比idx大的位置
    }
    cnt++//最后加上自身
    stake.push(price)
    spanner.push(cnt)
    return cnt
};
```





## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

### 暴力法   O(m*n)

```js
var dailyTemperatures = function (temperatures) {
    const n = temperatures.length
    const res = new Array(n).fill(0)
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            if (temperatures[i] < temperatures[j]) {
                res[i] = j - i
                break
            }
        }
    }
    return res
};
```

### 单调栈

*stack*=[2(75),3(71),4(69)]

当 i=5时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:=5-4 和 ans[3]:=5-3，将 5进栈。

stack=[2(75),5(72)]

ans=[1,1,0,2,1,0,0,0]



```js
var dailyTemperatures = function (temperatures) {
    const stake = [] //用于存储还未得到结果的下标
    const n = temperatures.length
    const ans = new Array(n).fill(0)
    for (let i = 0; i < n; i++) {
        let t = temperatures[i]
        while (stake.length && temperatures[stake[stake.length - 1]] < t) {//stake栈顶下标元素于当前t的大小
            let pre = stake.pop()//得到结果的下标出栈
            ans[pre] = i - pre
        }
        stake.push(i)//当前下标入栈
    }
    return ans
};
```



## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

### 解题思路

既然是求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。

比如 `[2,4,1,2]` ,以`1` 为最小数。能构成的数组数为 `(2+1)*(1+1)` ，`2` 表示 `1 `左面有两个比它大的数，`1` 表示 `1` 右面有一个比它大的数。

用单调栈求出 `A[i]` 对应的左右最近比 `A[i]` 小的数，记索引为 `prev,next，A[i] `为最小数能形成的数组为

```
(i-prev[i])*(next[i]-i)
```

这里为什么没有加 `1` 了呢，因为 `prev[i]`已经是比 `A[i]` 小的数了，能和 `A[i]` 形成数组的都是比 `A[i]` 大的数。

### 补充

注释已经足够详细，还是补充一下，我参考了大佬的解题代码，只不过我是直接求出来了以当前 `A[i]` 为最小值的子数组左右两边 大于或等于当前值的个数。这样后续求和直接相乘即可。（不过这里要**强调一下**，如果左边设置大于等于了，右边就只能是大于了，不然会重复计算相等的值）

开始有点看不懂大佬为啥左边初始化为 `-1`，右边初始化为 `A.length` 。假如我们遇到了这种情况，左边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时左边个数应该为 `i+1`（从 0 开始计数嘛），那么这部分大佬设为 `-1` 就很巧妙了，问题也就自然明白啦，个人感觉自己写的还是比较好理解一点，不然直接弄一个 `-1` ，第一次用单调栈，还是不太熟...

那么对于右边初始化为 `A.length` ，也是同理啦，当右边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时右边个数应该为 `A.length-i`（不用`+1`的原因是从0计数），那么这部分大佬设为 `A.length` 就很巧妙了，依旧清晰明了。

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubarrayMins = function(A) {
  let mod = 1e9+7
  // 维护一个栈
  let stack = []
  // 求以A[i]为最小值的子数组左边大于或等于自己的个数
  let prev = []
  for(let i=0;i<A.length;i++){
    while(stack.length && A[stack[stack.length-1]] >= A[i]) stack.pop()
    // 如果栈为空，即左边都比自己大，则返回i+1，否则返回i-栈顶元素（即保存的下标值）
    prev[i] = stack.length ? i - stack[stack.length-1] : i+1
    stack.push(i)
  }
  stack = []
  // 求以A[i]为最小值的子数组右边大于自己的个数（没有等号是因为不会重复计算相等的值）
  let nextv = []
  for(let i=A.length-1;i>=0;i--){
    while(stack.length && A[stack[stack.length-1]] > A[i]) stack.pop()
    // 如果栈为空，即右边都比自己大，则返回A.length-i，否则返回栈顶元素（即保存的下标值）-i
    nextv[i] = stack.length? stack[stack.length-1] - i : A.length-i
    stack.push(i)
  }
  let sum = 0
  for(let i=0;i<A.length;i++){
    // 以A[i] 为最小值的子数组的组合共有prev[i]*nextv[i]种情况，那么和的话乘以A[i]累加即可
    sum += (prev[i]*nextv[i]*A[i])
    // 按题意，进行取模运算
    sum %= mod
  }
  return sum
};
```



## [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

**示例 2：**

```
输入：s = "(u(love)i)"
输出："iloveu"
解释：先反转子字符串 "love" ，然后反转整个字符串。
```

### 做法一

```js
var reverseParentheses = function(s) {
    const stk = [];
    let str = '';
    for (const ch of s) {
        if (ch === '(') {
            stk.push(str);//遇到左括号把上次保存字符串的入栈
            str = '';
        } else if (ch === ')') {
            str = str.split("").reverse().join("");//转为数组 调用reverse方法再转为string
            str = stk[stk.length - 1] + str;//返回给上一层
            stk.pop();//栈顶字符串出栈
        } else {
            str += ch;
        }
    }
    return str;
};
```

O(n^2)

### 做法二 

<img src="%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/1.png" alt="img" style="zoom: 67%;" />

```js
var reverseParentheses = function(s) {
    const n = s.length;
    const pair = new Array(n).fill(0);
    const stack = [];
    for (let i = 0; i < n; i++) {//记录左右括号的匹配位置
        if (s[i] === '(') {
            stack.push(i);//用栈记录左括号位置
        } else if (s[i] == ')') {
            const j = stack.pop();//遇到右括号
            pair[i] = j;//右括号对应的左括号位置
            pair[j] = i;//左括号对应的右括号位置
        }
    }

    const sb = [];
    let index = 0, step = 1;
    while (index < n) {
        if (s[index] === '(' || s[index] === ')') {
            index = pair[index];//记录要跳转的位置
            step = -step;//判断方向
        } else {
            sb.push(s[index]);//加入char
        }
        index += step;
    }
    return sb.join('');
};
```



## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」

示例 1：

```
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
```

### 解题思路

一开始我是想着只要对应括号匹配就好了，将多余的右括号删掉，但是这个样例 `))((` 不可能过的，因为左括号也可以不匹配呀。于是我想着将括号对应字符串索引存起来，起初我们可以将不匹配的右括号还是按原来方法删掉就好了，匹配一个就删掉一个对应左括号的索引值，最后多出来的索引值全删掉就好了，这样就不会出现左括号还余留的情况。

这里提示一下：不要用 `splice`去删除指定下标的元素，`splice`会改变原数组长度，而你原本存的下标是基于原数组的。 `delete`方法不会改变数组长度，但删除的那个位置会变成`'undefined'`，所以我们用`fliter`方法过滤一遍出有效值 `arr=arr.filter(item=>item)`

最后通过 `res.join('')` 方法，将数组转换成我们最后要的字符串即可。

```js
var minRemoveToMakeValid = function (s) {
    let res = [...s]//转化为数组才能使用相关的删除方法
    const stake = []//用来保存未被匹配的括号位置
    let n = res.length
    for (i = 0; i < n; i++) {
        let char = s[i]
        if (char === '(') {
            stake.push(i)
        }
        if (char === ')') {
            if (stake.length) {
                stake.pop()//说明匹配到一对括号
            } else {//splice会改变原数组长度,delete会将该位置置为undefined,最后filter即可
                delete (res[i])
            }
        }
    }
    while(stake.length){
        delete (res[stake.pop()])//删除多余的左括号位置
    }
    res = res.filter(item=>item) //去除undefined
    return res.join('')
};
```





## 队列

## [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

示例：

```
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

```js
var RecentCounter = function () {
    this.line = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
    count = 0
    line = this.line
    for (num of line) {
        if (num >= t - 3000) count++
    }
    line.push(t)
    return count + 1
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

### 自己做法：

```js
var isValid = function (s) {
    const op = []
    for (str of s) {
        if (str === '(' || str === '{' || str === '[') op.push(str)
        if (str === ')' && op.pop() != '(' ||
            str === ']' && op.pop() != '[' ||
            str === '}' && op.pop() != '{') {
            return false
        }
    }
    return !op.length
};
```

### 官方做法：

```js
var isValid = function (s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([//构建哈希表  Map方法
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s) {
        if (pairs.has(ch)) { //是否包含该键   即判断是否是右括号
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;//栈为空，或者栈顶不匹配自己返回false
            }
            stk.pop();//出栈
        }
        else {//若是左括号则直接入栈
            stk.push(ch);
        }
    };
    return !stk.length;
};
```



## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：

1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列

```js
var validateStackSequences = function (pushed, popped) {
    const stack = []
    let j = 0
    for (x of pushed) {
        stack.push(x)//先进栈，再判断    JS中没有peek()方法
        while (stack.length>0 && stack[stack.length-1] === popped[j]) {//检查栈顶元素是否和pop的当前元素相等
            stack.pop()
            j++ //poped栈后移
        }
    }
    return stack.length===0 //判断stack是否清空
};
```



## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者
- 它可以被写作 `(A)`，其中 `A` 是有效字符串。

给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

**示例 ：**

```
输入："()))(("
输出：4
```

```js
var minAddToMakeValid = function (s) {
    const stake = []
    for (char of s) {
        //只有当栈顶为左括号，当前为右括号才弹出
        if (stake.length && stake[stake.length - 1] === '(' && char === ')') {
            stake.pop()
        }else{//其他情况全部压入栈中
            stake.push(char)
        }
    }
    return stake.length
};
```



## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)

编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。

示例：

```
输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

提示：

```
调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
每个测试用例最多可以调用  10000 次 StockSpanner.next。
在所有测试用例中，最多调用 150000 次 StockSpanner.next。
此问题的总时间限制减少了 50%。
```

### 自己做法（运行时间久，每次都要从当前位置向前一直判断）

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    let spanner = 1
    let n = this.stake.length
    while (this.stake[n - spanner] <= price) {
        spanner++
    }
    this.stake.push(price)
    return spanner
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = new StockSpanner()
 * var param_1 = obj.next(price)
 */
```

### 单调栈   解题思路

正如题意，我们要求当前元素之前，比自己小（可以相等）的元素个数，并且元素个数包括本身，那么我们最后的结果应该还要加1.

于是按题意，我们采用跨度法，举个例子，对于例子6，1，2，3，4，9，从后往前逆推一下，当我们新插入9的时候，如果发现前一位的4比9小，那么是否说明比9小的数量就等于比4小的数量加1？然而这是错的，因为首位的6比9小，却比4大，因此截止数字的4时候，比4小的数量中并不包含6与9的对比。

因此，我们还要跳到 6 的位置再去计算小于等于自己的元素。

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    const stake = this.stake
    const spanner = this.spanner
    if(!stake.length){//判断特殊情况
        stake.push(price)
        spanner.push(1)
        return 1
    }
    let cnt =0;//当前跨度数量
    let idx = stake.length-1;//比较的位置
    while(stake.length>0 && price>=stake[idx]){
        cnt += spanner[idx]//计数+当前跨度
        idx -= spanner[idx]//移动到比idx大的位置
    }
    cnt++//最后加上自身
    stake.push(price)
    spanner.push(cnt)
    return cnt
};
```





## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

### 暴力法   O(m*n)

```js
var dailyTemperatures = function (temperatures) {
    const n = temperatures.length
    const res = new Array(n).fill(0)
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            if (temperatures[i] < temperatures[j]) {
                res[i] = j - i
                break
            }
        }
    }
    return res
};
```

### 单调栈

*stack*=[2(75),3(71),4(69)]

当 i=5时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:=5-4 和 ans[3]:=5-3，将 5进栈。

stack=[2(75),5(72)]

ans=[1,1,0,2,1,0,0,0]



```js
var dailyTemperatures = function (temperatures) {
    const stake = [] //用于存储还未得到结果的下标
    const n = temperatures.length
    const ans = new Array(n).fill(0)
    for (let i = 0; i < n; i++) {
        let t = temperatures[i]
        while (stake.length && temperatures[stake[stake.length - 1]] < t) {//stake栈顶下标元素于当前t的大小
            let pre = stake.pop()//得到结果的下标出栈
            ans[pre] = i - pre
        }
        stake.push(i)//当前下标入栈
    }
    return ans
};
```



## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

### 解题思路

既然是求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。

比如 `[2,4,1,2]` ,以`1` 为最小数。能构成的数组数为 `(2+1)*(1+1)` ，`2` 表示 `1 `左面有两个比它大的数，`1` 表示 `1` 右面有一个比它大的数。

用单调栈求出 `A[i]` 对应的左右最近比 `A[i]` 小的数，记索引为 `prev,next，A[i] `为最小数能形成的数组为

```
(i-prev[i])*(next[i]-i)
```

这里为什么没有加 `1` 了呢，因为 `prev[i]`已经是比 `A[i]` 小的数了，能和 `A[i]` 形成数组的都是比 `A[i]` 大的数。

### 补充

注释已经足够详细，还是补充一下，我参考了大佬的解题代码，只不过我是直接求出来了以当前 `A[i]` 为最小值的子数组左右两边 大于或等于当前值的个数。这样后续求和直接相乘即可。（不过这里要**强调一下**，如果左边设置大于等于了，右边就只能是大于了，不然会重复计算相等的值）

开始有点看不懂大佬为啥左边初始化为 `-1`，右边初始化为 `A.length` 。假如我们遇到了这种情况，左边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时左边个数应该为 `i+1`（从 0 开始计数嘛），那么这部分大佬设为 `-1` 就很巧妙了，问题也就自然明白啦，个人感觉自己写的还是比较好理解一点，不然直接弄一个 `-1` ，第一次用单调栈，还是不太熟...

那么对于右边初始化为 `A.length` ，也是同理啦，当右边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时右边个数应该为 `A.length-i`（不用`+1`的原因是从0计数），那么这部分大佬设为 `A.length` 就很巧妙了，依旧清晰明了。

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubarrayMins = function(A) {
  let mod = 1e9+7
  // 维护一个栈
  let stack = []
  // 求以A[i]为最小值的子数组左边大于或等于自己的个数
  let prev = []
  for(let i=0;i<A.length;i++){
    while(stack.length && A[stack[stack.length-1]] >= A[i]) stack.pop()
    // 如果栈为空，即左边都比自己大，则返回i+1，否则返回i-栈顶元素（即保存的下标值）
    prev[i] = stack.length ? i - stack[stack.length-1] : i+1
    stack.push(i)
  }
  stack = []
  // 求以A[i]为最小值的子数组右边大于自己的个数（没有等号是因为不会重复计算相等的值）
  let nextv = []
  for(let i=A.length-1;i>=0;i--){
    while(stack.length && A[stack[stack.length-1]] > A[i]) stack.pop()
    // 如果栈为空，即右边都比自己大，则返回A.length-i，否则返回栈顶元素（即保存的下标值）-i
    nextv[i] = stack.length? stack[stack.length-1] - i : A.length-i
    stack.push(i)
  }
  let sum = 0
  for(let i=0;i<A.length;i++){
    // 以A[i] 为最小值的子数组的组合共有prev[i]*nextv[i]种情况，那么和的话乘以A[i]累加即可
    sum += (prev[i]*nextv[i]*A[i])
    // 按题意，进行取模运算
    sum %= mod
  }
  return sum
};
```



## [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

**示例 2：**

```
输入：s = "(u(love)i)"
输出："iloveu"
解释：先反转子字符串 "love" ，然后反转整个字符串。
```

### 做法一

```js
var reverseParentheses = function(s) {
    const stk = [];
    let str = '';
    for (const ch of s) {
        if (ch === '(') {
            stk.push(str);//遇到左括号把上次保存字符串的入栈
            str = '';
        } else if (ch === ')') {
            str = str.split("").reverse().join("");//转为数组 调用reverse方法再转为string
            str = stk[stk.length - 1] + str;//返回给上一层
            stk.pop();//栈顶字符串出栈
        } else {
            str += ch;
        }
    }
    return str;
};
```

O(n^2)

### 做法二 

<img src="%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/1.png" alt="img" style="zoom: 67%;" />

```js
var reverseParentheses = function(s) {
    const n = s.length;
    const pair = new Array(n).fill(0);
    const stack = [];
    for (let i = 0; i < n; i++) {//记录左右括号的匹配位置
        if (s[i] === '(') {
            stack.push(i);//用栈记录左括号位置
        } else if (s[i] == ')') {
            const j = stack.pop();//遇到右括号
            pair[i] = j;//右括号对应的左括号位置
            pair[j] = i;//左括号对应的右括号位置
        }
    }

    const sb = [];
    let index = 0, step = 1;
    while (index < n) {
        if (s[index] === '(' || s[index] === ')') {
            index = pair[index];//记录要跳转的位置
            step = -step;//判断方向
        } else {
            sb.push(s[index]);//加入char
        }
        index += step;
    }
    return sb.join('');
};
```



## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」

示例 1：

```
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
```

### 解题思路

一开始我是想着只要对应括号匹配就好了，将多余的右括号删掉，但是这个样例 `))((` 不可能过的，因为左括号也可以不匹配呀。于是我想着将括号对应字符串索引存起来，起初我们可以将不匹配的右括号还是按原来方法删掉就好了，匹配一个就删掉一个对应左括号的索引值，最后多出来的索引值全删掉就好了，这样就不会出现左括号还余留的情况。

这里提示一下：不要用 `splice`去删除指定下标的元素，`splice`会改变原数组长度，而你原本存的下标是基于原数组的。 `delete`方法不会改变数组长度，但删除的那个位置会变成`'undefined'`，所以我们用`fliter`方法过滤一遍出有效值 `arr=arr.filter(item=>item)`

最后通过 `res.join('')` 方法，将数组转换成我们最后要的字符串即可。

```js
var minRemoveToMakeValid = function (s) {
    let res = [...s]//转化为数组才能使用相关的删除方法
    const stake = []//用来保存未被匹配的括号位置
    let n = res.length
    for (i = 0; i < n; i++) {
        let char = s[i]
        if (char === '(') {
            stake.push(i)
        }
        if (char === ')') {
            if (stake.length) {
                stake.pop()//说明匹配到一对括号
            } else {//splice会改变原数组长度,delete会将该位置置为undefined,最后filter即可
                delete (res[i])
            }
        }
    }
    while(stake.length){
        delete (res[stake.pop()])//删除多余的左括号位置
    }
    res = res.filter(item=>item) //去除undefined
    return res.join('')
};
```





## 队列

## [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

示例：

```
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

```js
var RecentCounter = function () {
    this.line = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
    count = 0
    line = this.line
    for (num of line) {
        if (num >= t - 3000) count++
    }
    line.push(t)
    return count + 1
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

### 自己做法：

```js
var isValid = function (s) {
    const op = []
    for (str of s) {
        if (str === '(' || str === '{' || str === '[') op.push(str)
        if (str === ')' && op.pop() != '(' ||
            str === ']' && op.pop() != '[' ||
            str === '}' && op.pop() != '{') {
            return false
        }
    }
    return !op.length
};
```

### 官方做法：

```js
var isValid = function (s) {
    const n = s.length;
    if (n % 2 === 1) {
        return false;
    }
    const pairs = new Map([//构建哈希表  Map方法
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    const stk = [];
    for (let ch of s) {
        if (pairs.has(ch)) { //是否包含该键   即判断是否是右括号
            if (!stk.length || stk[stk.length - 1] !== pairs.get(ch)) {
                return false;//栈为空，或者栈顶不匹配自己返回false
            }
            stk.pop();//出栈
        }
        else {//若是左括号则直接入栈
            stk.push(ch);
        }
    };
    return !stk.length;
};
```



## [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

提示：

1 <= pushed.length <= 1000
0 <= pushed[i] <= 1000
pushed 的所有元素 互不相同
popped.length == pushed.length
popped 是 pushed 的一个排列

```js
var validateStackSequences = function (pushed, popped) {
    const stack = []
    let j = 0
    for (x of pushed) {
        stack.push(x)//先进栈，再判断    JS中没有peek()方法
        while (stack.length>0 && stack[stack.length-1] === popped[j]) {//检查栈顶元素是否和pop的当前元素相等
            stack.pop()
            j++ //poped栈后移
        }
    }
    return stack.length===0 //判断stack是否清空
};
```



## [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

- 它是一个空字符串，或者
- 它可以被写成 `AB` （`A` 与 `B` 连接）, 其中 `A` 和 `B` 都是有效字符串，或者
- 它可以被写作 `(A)`，其中 `A` 是有效字符串。

给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

**示例 ：**

```
输入："()))(("
输出：4
```

```js
var minAddToMakeValid = function (s) {
    const stake = []
    for (char of s) {
        //只有当栈顶为左括号，当前为右括号才弹出
        if (stake.length && stake[stake.length - 1] === '(' && char === ')') {
            stake.pop()
        }else{//其他情况全部压入栈中
            stake.push(char)
        }
    }
    return stake.length
};
```



## [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)

编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。

示例：

```
输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

提示：

```
调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
每个测试用例最多可以调用  10000 次 StockSpanner.next。
在所有测试用例中，最多调用 150000 次 StockSpanner.next。
此问题的总时间限制减少了 50%。
```

### 自己做法（运行时间久，每次都要从当前位置向前一直判断）

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    let spanner = 1
    let n = this.stake.length
    while (this.stake[n - spanner] <= price) {
        spanner++
    }
    this.stake.push(price)
    return spanner
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = new StockSpanner()
 * var param_1 = obj.next(price)
 */
```

### 单调栈   解题思路

正如题意，我们要求当前元素之前，比自己小（可以相等）的元素个数，并且元素个数包括本身，那么我们最后的结果应该还要加1.

于是按题意，我们采用跨度法，举个例子，对于例子6，1，2，3，4，9，从后往前逆推一下，当我们新插入9的时候，如果发现前一位的4比9小，那么是否说明比9小的数量就等于比4小的数量加1？然而这是错的，因为首位的6比9小，却比4大，因此截止数字的4时候，比4小的数量中并不包含6与9的对比。

因此，我们还要跳到 6 的位置再去计算小于等于自己的元素。

```js
var StockSpanner = function () {
    // 存储股票跨度
    this.spanner = []
    // 存储股票价格
    this.stake = []
};

/** 
 * @param {number} price
 * @return {number}
 */
StockSpanner.prototype.next = function (price) {
    const stake = this.stake
    const spanner = this.spanner
    if(!stake.length){//判断特殊情况
        stake.push(price)
        spanner.push(1)
        return 1
    }
    let cnt =0;//当前跨度数量
    let idx = stake.length-1;//比较的位置
    while(stake.length>0 && price>=stake[idx]){
        cnt += spanner[idx]//计数+当前跨度
        idx -= spanner[idx]//移动到比idx大的位置
    }
    cnt++//最后加上自身
    stake.push(price)
    spanner.push(cnt)
    return cnt
};
```





## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

### 暴力法   O(m*n)

```js
var dailyTemperatures = function (temperatures) {
    const n = temperatures.length
    const res = new Array(n).fill(0)
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            if (temperatures[i] < temperatures[j]) {
                res[i] = j - i
                break
            }
        }
    }
    return res
};
```

### 单调栈

*stack*=[2(75),3(71),4(69)]

当 i=5时，由于 72 大于 69 和 71，因此依次移除栈顶元素 4 和 3，赋值 ans[4]:=5-4 和 ans[3]:=5-3，将 5进栈。

stack=[2(75),5(72)]

ans=[1,1,0,2,1,0,0,0]



```js
var dailyTemperatures = function (temperatures) {
    const stake = [] //用于存储还未得到结果的下标
    const n = temperatures.length
    const ans = new Array(n).fill(0)
    for (let i = 0; i < n; i++) {
        let t = temperatures[i]
        while (stake.length && temperatures[stake[stake.length - 1]] < t) {//stake栈顶下标元素于当前t的大小
            let pre = stake.pop()//得到结果的下标出栈
            ans[pre] = i - pre
        }
        stake.push(i)//当前下标入栈
    }
    return ans
};
```



## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

### 解题思路

既然是求子数组中最小值的和，就是求 以 A[i] 作为最小数能构成的数组有多少个。

比如 `[2,4,1,2]` ,以`1` 为最小数。能构成的数组数为 `(2+1)*(1+1)` ，`2` 表示 `1 `左面有两个比它大的数，`1` 表示 `1` 右面有一个比它大的数。

用单调栈求出 `A[i]` 对应的左右最近比 `A[i]` 小的数，记索引为 `prev,next，A[i] `为最小数能形成的数组为

```
(i-prev[i])*(next[i]-i)
```

这里为什么没有加 `1` 了呢，因为 `prev[i]`已经是比 `A[i]` 小的数了，能和 `A[i]` 形成数组的都是比 `A[i]` 大的数。

### 补充

注释已经足够详细，还是补充一下，我参考了大佬的解题代码，只不过我是直接求出来了以当前 `A[i]` 为最小值的子数组左右两边 大于或等于当前值的个数。这样后续求和直接相乘即可。（不过这里要**强调一下**，如果左边设置大于等于了，右边就只能是大于了，不然会重复计算相等的值）

开始有点看不懂大佬为啥左边初始化为 `-1`，右边初始化为 `A.length` 。假如我们遇到了这种情况，左边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时左边个数应该为 `i+1`（从 0 开始计数嘛），那么这部分大佬设为 `-1` 就很巧妙了，问题也就自然明白啦，个人感觉自己写的还是比较好理解一点，不然直接弄一个 `-1` ，第一次用单调栈，还是不太熟...

那么对于右边初始化为 `A.length` ，也是同理啦，当右边都比当前 `A[i]` 要大，那我们维护的单调递减栈就会不断出栈，不断出栈，直到栈为空为止，此时右边个数应该为 `A.length-i`（不用`+1`的原因是从0计数），那么这部分大佬设为 `A.length` 就很巧妙了，依旧清晰明了。

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubarrayMins = function(A) {
  let mod = 1e9+7
  // 维护一个栈
  let stack = []
  // 求以A[i]为最小值的子数组左边大于或等于自己的个数
  let prev = []
  for(let i=0;i<A.length;i++){
    while(stack.length && A[stack[stack.length-1]] >= A[i]) stack.pop()
    // 如果栈为空，即左边都比自己大，则返回i+1，否则返回i-栈顶元素（即保存的下标值）
    prev[i] = stack.length ? i - stack[stack.length-1] : i+1
    stack.push(i)
  }
  stack = []
  // 求以A[i]为最小值的子数组右边大于自己的个数（没有等号是因为不会重复计算相等的值）
  let nextv = []
  for(let i=A.length-1;i>=0;i--){
    while(stack.length && A[stack[stack.length-1]] > A[i]) stack.pop()
    // 如果栈为空，即右边都比自己大，则返回A.length-i，否则返回栈顶元素（即保存的下标值）-i
    nextv[i] = stack.length? stack[stack.length-1] - i : A.length-i
    stack.push(i)
  }
  let sum = 0
  for(let i=0;i<A.length;i++){
    // 以A[i] 为最小值的子数组的组合共有prev[i]*nextv[i]种情况，那么和的话乘以A[i]累加即可
    sum += (prev[i]*nextv[i]*A[i])
    // 按题意，进行取模运算
    sum %= mod
  }
  return sum
};
```



## [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

**示例 2：**

```
输入：s = "(u(love)i)"
输出："iloveu"
解释：先反转子字符串 "love" ，然后反转整个字符串。
```

### 做法一

```js
var reverseParentheses = function(s) {
    const stk = [];
    let str = '';
    for (const ch of s) {
        if (ch === '(') {
            stk.push(str);//遇到左括号把上次保存字符串的入栈
            str = '';
        } else if (ch === ')') {
            str = str.split("").reverse().join("");//转为数组 调用reverse方法再转为string
            str = stk[stk.length - 1] + str;//返回给上一层
            stk.pop();//栈顶字符串出栈
        } else {
            str += ch;
        }
    }
    return str;
};
```

O(n^2)

### 做法二 

<img src="%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.assets/1.png" alt="img" style="zoom: 67%;" />

```js
var reverseParentheses = function(s) {
    const n = s.length;
    const pair = new Array(n).fill(0);
    const stack = [];
    for (let i = 0; i < n; i++) {//记录左右括号的匹配位置
        if (s[i] === '(') {
            stack.push(i);//用栈记录左括号位置
        } else if (s[i] == ')') {
            const j = stack.pop();//遇到右括号
            pair[i] = j;//右括号对应的左括号位置
            pair[j] = i;//左括号对应的右括号位置
        }
    }

    const sb = [];
    let index = 0, step = 1;
    while (index < n) {
        if (s[index] === '(' || s[index] === ')') {
            index = pair[index];//记录要跳转的位置
            step = -step;//判断方向
        } else {
            sb.push(s[index]);//加入char
        }
        index += step;
    }
    return sb.join('');
};
```



## [1249. 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」

示例 1：

```
输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
```

### 解题思路

一开始我是想着只要对应括号匹配就好了，将多余的右括号删掉，但是这个样例 `))((` 不可能过的，因为左括号也可以不匹配呀。于是我想着将括号对应字符串索引存起来，起初我们可以将不匹配的右括号还是按原来方法删掉就好了，匹配一个就删掉一个对应左括号的索引值，最后多出来的索引值全删掉就好了，这样就不会出现左括号还余留的情况。

这里提示一下：不要用 `splice`去删除指定下标的元素，`splice`会改变原数组长度，而你原本存的下标是基于原数组的。 `delete`方法不会改变数组长度，但删除的那个位置会变成`'undefined'`，所以我们用`fliter`方法过滤一遍出有效值 `arr=arr.filter(item=>item)`

最后通过 `res.join('')` 方法，将数组转换成我们最后要的字符串即可。

```js
var minRemoveToMakeValid = function (s) {
    let res = [...s]//转化为数组才能使用相关的删除方法
    const stake = []//用来保存未被匹配的括号位置
    let n = res.length
    for (i = 0; i < n; i++) {
        let char = s[i]
        if (char === '(') {
            stake.push(i)
        }
        if (char === ')') {
            if (stake.length) {
                stake.pop()//说明匹配到一对括号
            } else {//splice会改变原数组长度,delete会将该位置置为undefined,最后filter即可
                delete (res[i])
            }
        }
    }
    while(stake.length){
        delete (res[stake.pop()])//删除多余的左括号位置
    }
    res = res.filter(item=>item) //去除undefined
    return res.join('')
};
```





## 队列

## [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

RecentCounter() 初始化计数器，请求数为 0 。
int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
保证 每次对 ping 的调用都使用比之前更大的 t 值。

示例：

```
输入：
["RecentCounter", "ping", "ping", "ping", "ping"]
[[], [1], [100], [3001], [3002]]
输出：
[null, 1, 2, 3, 3]

解释：
RecentCounter recentCounter = new RecentCounter();
recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3
```

```js
var RecentCounter = function () {
    this.line = []
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function (t) {
    count = 0
    line = this.line
    for (num of line) {
        if (num >= t - 3000) count++
    }
    line.push(t)
    return count + 1
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
