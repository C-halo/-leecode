<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree1.jpg" alt="img" style="zoom: 50%;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree2.jpg" alt="img" style="zoom: 50%;" />

### 思路：

[1,2,3,4,5,6,7,8]

中间的作为根节点值，左右子树则为两边内部递归

自己做法：

```js
var sortedArrayToBST = function (nums) {
    let n = nums.length;
    if (!n) return null;
    let mid = Math.floor(n / 2);
    let tree = new TreeNode(nums[mid]);
    let left = nums.slice(0, mid);
    let right = nums.slice(mid + 1);
    tree.left = sortedArrayToBST(left);
    tree.right = sortedArrayToBST(right);
    return tree;
};
```

```js
var sortedArrayToBST = function (nums) {
    let dfs = (left, right) => {
        if (left > right) return null//说明没有元素可选了
        let tree = new TreeNode()
        let mid = Math.floor((left + right) / 2)
        tree.val = nums[mid]
        tree.left = dfs(left, mid - 1)//左子树
        tree.right = dfs(mid + 1, right)//右子树
        return tree
    }
    let tree = dfs(0, nums.length - 1)
    return tree
};
```



## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/binarytree.png" alt="img" style="zoom: 67%;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

### 思路：

根据定义，我们知道，假设 `root` 为 `p、q` 的最近公共祖先，则只可能有如下几种情况：

- p、q 在 root 的子树中，那么 p、q 分在 root 的左右子树中
- 如果 p = root，那么 q 会在 p 的左右子树中，直接返回 p 即可
- 如果 q = root，与上述类似

然后我们采用 `后序遍历`的方式，先遍历左右子树，看能不能找到对应 `p` 和 `q` 节点。

如果左右子树都能找到，那么代表p、q 分在 root 的左右子树中，直接返回 root 节点 如果左子树找到，右子树没找到，那么就返回左子树的查找结果 如果右子树找到，左子树没找到，那么就返回右子树的查找结果

<img src="https://camo.githubusercontent.com/702bfc252c95673e805fbb1d4a55684d5e9b8569320ef473e8b4f67824502c44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343138343431393638382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var lowestCommonAncestor = function (root, p, q) {
    if (!root || root == p || root == q) return root;//当前的节点为空，或者root == p || root == q则返回root
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    // 如果当前root 在左右子树下可以找到 p q 那么这个root就是它们的最近公共祖先
    if(left && right) return root; 
    // 如果当前root 只有左子树有节点，那么这个节点本身就是p、q的祖先
    else if(left) return left;
    // 如果当前root 只有右子树有节点，那么这个节点本身就是p、q的祖先
    else return right;
};
```





## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

示例:

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

### 思路：

对于这道题，我们必须先了解一下二叉搜索树（BST）的性质，如下：

BST性质

- 中序遍历是升序
- left小于当前节点，right大于当前节点
- 左子树、右子树也要是BST

了解了性质之后，我们知道要查找对应 `key` 值，可以与根节点进行比较，如果小于根节点，直接去左子树找就好了，如果大于根节点，直接去右子树找就好了。

而对于刚好等于根节点的话，我拿着大佬的图解来看看几种情况：

第一种情况，如果删除节点仅有右孩子，直接指向右孩子

<img src="https://camo.githubusercontent.com/4588e46a49f1e84644621d25252378ce5988ef0c467c644ba192ed2be57d6793/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323431363532322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第二种情况，如果删除节点仅有左孩子，直接指向左孩子

<img src="https://camo.githubusercontent.com/bf473e0d3694e56128eaba901eaad094d4af47564a48922fce32a10ed72c1d4f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303039323432323234323438392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第三种情况，如果删除节点左右孩子都有，那么我们按照题意可以有两种删除方法：

① 找到要删除节点左子树的最右边的节点，即前驱的最大值（由BST性质得到）替换当前 root 节点，然后删除这个前驱

② 找到要删除节点右子树的最左边的节点，即后继最小值（由BST性质得到）替换当前 root 节点，然后删除这个后继

<img src="https://camo.githubusercontent.com/80ff4c6af92f0ef7bed318f37033a1c276aba3d5c0224c7afd2e0e45f7d423fb/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323433303435342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var deleteNode = function (root, key) {
    if (!root) return null
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        if (!root.left && !root.right) {//要删除的节点没有左右子树
            root = null
        } else if (!root.left) {//要删除的节点没有左子树
            root = root.right
        } else if (!root.right) {//要删除的节点没有右子树
            root = root.left
        } else {//左右子树都有，使用右子树的最小值作为返回值
            let node = root.right
            while (node.left) {
                node = node.left
            }
            root.val = node.val//令root的值为右子树的最小值
            //node必是没有子树的节点，调用函数删除
            root.right = deleteNode(root.right, node.val)
        }
    }
    return root
}
```



## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给定一个有相同值的二叉搜索树（**BST**），找出 **BST** 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

```
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 思路:

由于 `BST`（二叉搜索树）的特殊性，我们采用递归来中序遍历，访问的节点值是有序的。然后重复节点，用计数器进行累加即可，如果有新值出现，则更新新值，然后计数器重置为 1。然后对于当前次数超过了最大值，则更新当前最大值，如果等于最大值，则代表出现了相同频率的数字，加入即可。

如果次数小于最大值，不需要什么操作。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    let cnt = 0;
    let pre = 0;
    let res = [];
    let maxCnt = 0;
    let handle = (cur) => {
        // 相同的数，累加
        if(cur === pre){
            cnt++;
        }else{
            // 有新数出现，重新置计数器为1，更新新数
            pre = cur;
            cnt = 1;
        }
        // 如果次数超过了最大值，更新当前最大值
        if(cnt > maxCnt){
            maxCnt = cnt;
            res = [cur];//结果也更新
        // 如果有相同频率的数字出现，直接加入
        }else if(cnt === maxCnt){
            res.push(cur);
        }
    }
    // 二叉搜索树，递归中序遍历方式
    let inOrder = (root) =>{
        if(!root) return null;
        inOrder(root.left);
        handle(root.val);
        inOrder(root.right);
    }
    inOrder(root);
    return res;
};
```





## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

### 解法：

```js
var hasPathSum = function (root, targetSum) {
    if (!root) return false
    let flag = false
    let dfs = (root, targetSum) => {
        targetSum -= root.val//先减去
        if (!root.left && !root.right) {//若当前是叶子节点
            if (targetSum === 0) {//若当前符合条件，直接返回
                flag = true
            }
            return
        }
        // 先遍历左子树，再遍历右子树
        root.left && dfs(root.left, targetSum);//有左子树才递归
        root.right && dfs(root.right, targetSum);//有右子树才递归
    }
    dfs(root, targetSum)
    return flag
}
```



## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

### 思路：

同样的思路，相比于上一题，只是要求将路径记录下来

```js
var pathSum = function (root, targetSum) {
    let res = []
    let dfs = (root, sum, arr) => {
        if (!root) return
        sum += root.val
        arr.push(root.val)
        if (!root.left && !root.right) {
            if (sum === targetSum) {
                res.push(arr)
            }
            return
        }
        root.left && dfs(root.left, sum, arr.slice())
        root.right && dfs(root.right, sum, arr.slice())
    }
    dfs(root, 0, [])
    return res
};
```



## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/pathsum3-1-tree.jpg" alt="img" style="zoom: 50%;" />

### 思路：

先序遍历每一个节点，以每一个节点为起点都执行一遍路径检查，路径检查中只要累加为target计数就+1，以叶子节点为结束标志

### 自己做法:

```js
var pathSum = function (root, targetSum) {
    let res = 0
    let judge = (root, sum) => {
        //if (!root) return;  此语句不需要了
        sum += root.val
        if (sum === targetSum) res++
        root.left && judge(root.left, sum)//在执行下一节点先判断有没有子树，递归中就不需要判断为空的条件
        root.right && judge(root.right, sum)
    }
    if (!root) return 0
    let dfs = (root) => {//每个节点为起点执行一遍judge函数
        judge(root, 0)
        root.left && dfs(root.left, 0)
        root.right && dfs(root.right, 0)
    }
    dfs(root)
    return res
}
```

### 其他做法：

```js
var pathSum = function (root, sum) {
    // 定义一个计时器
    let cnt = 0;
    // 先序遍历所有根节点
    let preOrder = (root, sum) => {
        if (root == null) return;
        dfs(root, sum);
        preOrder(root.left, sum);
        preOrder(root.right, sum);
    }
    let dfs = (root, sum) => {
        if (root == null) return;
        sum -= root.val;
        // 求和满足，累加
        if (sum === 0) cnt++;
        // 递归左右子树，如果当前和为0了，但是下面还是有路，还是继续走下去
        // 因为本题数值范围存在负数，可能继续走下去还存在满足条件的路径
        dfs(root.left, sum);
        dfs(root.right, sum);
    }
    preOrder(root, sum);
    return cnt;
};
```



## [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

示例 1:

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

### 思路：

每下降一层就假如当前记和，知道遇到叶子节点，直接加入总计数中

```js
var sumNumbers = function (root) {
    let sum = 0
    let dfs = (root, cur) => {
        cur = cur * 10 + root.val
        if (!root.left && !root.right) {//假如是叶子节点
            sum += cur
        }
        root.left && dfs(root.left, cur)
        root.right && dfs(root.right, cur)
    }
    dfs(root, 0)
    return sum
};
```





## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

示例:

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

### 解法：

```js
var binaryTreePaths = function (root) {
    let res = []
    let dfs = (root, str) => {
        if (!root.left && !root.right) {
            str += root.val + ''
            return res.push(str)
        }
        else {
            str += root.val + '->'
        }
        root.left && dfs(root.left, str)
        root.right && dfs(root.right, str)
    }
    dfs(root, '')
    return res
};
```



## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

### 解题思路:

`dfs`，求左叶子之和，叶子结点我们比较好判断，而对于左孩子，我们设置一个标记就好了，例如左孩子标记 `1`，右孩子标记 `0`，那么当且仅当是叶子节点，并且标记为 `1`（即左孩子）时，我们进行累加求和。

```js
var sumOfLeftLeaves = function (root) {
    if (!root) return 0
    let sum = 0
    let dfs = (root, cur) => {
        if (!root.left && !root.right && cur) {
            sum += root.val
            return
        }
        root.left && dfs(root.left, 1)
        root.right && dfs(root.right, 0)
    }
    dfs(root, 0)
    return sum
};
```



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
 
```

### 解法：

递归

```js
var isSymmetric = function (root) {
    if (!root) return true
    let dfs = (left, right) => {
        if (!left && !right) return true //左右子树都为空，可以
        if (!left && right) return false //左子树为空，右子树有值，不可
        if (left && !right) return false //同上
        if (left.val !== right.val) return false//若值不相等，不可
        else {
            return dfs(left.left, right.right) && dfs(left.right, right.left)//镜像判断
        }
    }
    return dfs(root.left, root.right)
};
```

迭代

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if (!root) return true
    let queue = [root.left, root.right]
    while (queue.length) {
        let node1 = queue.shift()
        let node2 = queue.shift()
        if (!node1 && !node2) continue
        if (!node1 || !node2 || node1.val !== node2.val) return false
        queue.push(node1.left)
        queue.push(node2.right)
        queue.push(node1.right)
        queue.push(node2.left)
    }
    return true
};
```

### 自己做法：

将左子树翻转再与右子树判断是否相等

```js
var isSymmetric = function (root) {
    let dfs = (root) => {//将树镜像翻转
        let temp = root.left
        root.left = root.right
        root.right = temp
        root.left && dfs(root.left)
        root.right && dfs(root.right)
    }
    let isSameTree = (p, q) => {//判断两棵树是否一样
        if (!p && !q) return true
        if (!p && q) return false
        if (p && !q) return false
        if (p.val !== q.val) return false
        else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        }
    }
    root.left && dfs(root.left)
    if (isSameTree(root.left, root.right)) return true//将左子树翻转再与右子树判断是否相等
    return false
};
```

```js
var isSymmetric = function (root) {
    if (!root) return true;
    let recur = (left, right) => {
        if(left===null && right===null) return true;
        if(!left || !right ||left.val !== right.val) return false;
        return recur(left.left,right.right) && recur(left.right,right.left);
    }
    return recur(root.left,root.right);
};
```



## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

示例 3:

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 做法：

```js
var isSameTree = function (p, q) {
    if (!p && !q) return true
    if (!p && q) return false
    if (p && !q) return false
    if (p.val !== q.val) return false
    else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```



## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

示例:

```
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
```

### 解法：

```js
var minDepth = function (root) {
    if (!root) return 0
    let minh = Number.MAX_VALUE
    let dfs = (root, h) => {
        h++
        if (!root.left && !root.right) {
            minh = h < minh ? h : minh
        }
        root.left && dfs(root.left, h)
        root.right && dfs(root.right, h)
    }
    dfs(root, 0)
    return minh
};
```





## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

### 思路：

先看右孩子，再看左孩子，若深度大于res长度，则说明可以被看到。

```js
var rightSideView = function (root) {
    if (!root) return []
    let res = []
    let dfs = (root, h) => {
        h++
        if (h > res.length) res.push(root.val)
        root.right && dfs(root.right, h)
        root.left && dfs(root.left, h)
    }
    dfs(root, 0)
    return res
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[[3], [9,20],[15,7]]
```

### 解法：

直接用 `BFS`，对于每一层初始化空数组，然后存放每一层的节点值，然后迭代即可。

```js
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let queue = [root] //开始queue的长度为1，存的是root节点
    while (queue.length) {
        let size = queue.length //当前层的节点数
        let temp = []
        while (size--) {//目的是将当前层节点的所有子节点存到queue中，方便下次迭代
            let node = queue.shift()//队首元素出队
            temp.push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        res.push(temp)
    }
    return res
};
```



## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

### 解法：

通过**后序遍历**，每一次返回当前根节点下的左右孩子的深度最大值，然后每一次递归求一下左右孩子路径和的最大值即可。

```js
var diameterOfBinaryTree = function (root) {
    if (!root) return 0;
    let res = 0;
    let dfs = (root) => {
        if (!root) return 0;
        // 后序遍历 先遍历左孩子
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 每次求直径，比较左右孩子路径和的最大值
        res = Math.max(left + right, res);
        // 递归时候返回左右孩子深度最长
        return Math.max(left, right)
    }
    dfs(root);
    return res;
};
```



## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1

示例 1:

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

示例 2:

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

### 思路：

`dfs`，平衡二叉树就是每个节点 的左右两个子树的高度差的绝对值不超过1。那么，我们可以自底向上，即采用后序遍历的方式，只要左右高度超过1了，直接设置 `flase`即可。

```js
 /**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
    if(!root) return true;
    let res = true;
    let dfs = (root) => {
        // 先遍历左子树，在遍历右子树
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 判断是否是平衡二叉树，就看高度差是否大于1
        if (Math.abs(left - right) > 1) res = false;
        // 返回左右子树深度的最大值
        return Math.max(left, right);
    }
    dfs(root);
    return res;
};
```





## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：

```
输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

示例 2：

```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```

### 思路：

后序遍历，先遍历左孩子，对于孩子的累计和，我们判断一下，如果小于0（即为负数）就没必要加了，直接返回 0 即可，否则加上孩子累计和。然后我们对每一层求一下最大值即可。

```js
var maxPathSum = function (root) {
    let max = Number.MIN_SAFE_INTEGER
    let dfs = (root) => {
        let left = root.left && dfs(root.left)
        let right = root.right && dfs(root.right)
        max = Math.max(max, left + right + root.val)//每判断一个新节点都看下左孩子和+根节点+右孩子之和是否大于最大值
        let sum = Math.max(left, right) + root.val//返回只返回最大的孩子和加根节点
        return sum > 0 ? sum : 0//假如小于0就返回0即可
    }
    dfs(root)
    return max
};
```





## [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
![image-20220410153805710](D:\前端\力扣leecode\二叉树.assets\image-20220410153805710.png)               ![image-20220410153819270](D:\前端\力扣leecode\二叉树.assets\image-20220410153819270.png)
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 解法：

```js
var isSubStructure = function (A, B) {
    let recur = (A, B) => {//判断当前节点的val是否相等
        if (!B) return true;//假如B为null,说明已经判断完毕，可以返回true
        if (!A || A.val !== B.val) return false;//假如不相等或者A都已经判定完了B还没判断完，返回false
        return recur(A.left, B.left) && recur(A.right, B.right);//当前的相等，看他们的字节点是否相等
    }
    //两个节点不能为空
    //判断A自身是否相等，不相等就递归判断左孩子，再递归判断右孩子
    return (A!==null && B!==null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
};
```





## [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

<img src="D:\前端\力扣leecode\二叉树.assets\image-20220410160729613.png" alt="image-20220410160729613"  />

### 解法：

从叶子节点先开始翻转得到镜像。如果当前遍历到的节点root的左右两棵子树都已经翻转得到镜像，那么我们只需要交换两棵子树的位置，即可得到以root 为根节点的整棵子树的镜像。

```js
var mirrorTree = function (root) {
    if(!root) return null;
    let left = mirrorTree(root.left);//让子树的左右交换，
    let right = mirrorTree(root.right);
    root.left = right;
    root.right =left;
    return root;
};
```



## [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

<img src="D:\前端\力扣leecode\二叉树.assets\bstdlloriginalbst.png" alt="img" style="zoom:33%;" />

<img src="D:\前端\力扣leecode\二叉树.assets\bstdllreturndll.png" alt="img" style="zoom:50%;" />

### 解法：

​	利用中序遍历

```js
var treeToDoublyList = function (root) {
    if (!root) return null;
    let head;
    let pre = null;

    let dfs = (root) => {
        if (!root) return;
        dfs(root.left);
        if (pre !== null) pre.right = root;//假如pre不为空，则令pre.right指向当前
        else head = root;//为空说明到了左叶子节点，为head
        root.left = pre;//当前的left指向pre
        pre = root;//中序遍历，更新pre
        dfs(root.right)
    }
    dfs(root);
    head.left = pre;
    pre.right = head;//退出时，pre指向右孩子节点
    return head
};
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

 **示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

### 解法：

中序遍历，计数

```js
var kthLargest = function (root, k) {//k大==n-k+1小
    let idx = 0;
    let v = 0;
    let dfs = (root) => {
        if (!root) return;
        dfs(root.right);
        if(idx === k)  return;//提前返回
        idx++;
        if (idx === k) {
            v =root.val
            return;
        }
        dfs(root.left);
    }
    dfs(root);
    return v;
};
```



## [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

示例 1:

<img src="D:\前端\力扣leecode\二叉树.assets\tree.jpg" alt="img" style="zoom: 50%;" />

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

### 解法：

 // 前序第一个元素  将中序分成左树 与右树
// 取出前序第一个元素做当前树根节点
// 绑定分治左树右树
// 返回当前节点节点

```js
var buildTree = function(preorder, inorder) {
    if(preorder.length <= 0) return null
    let val = preorder.shift();
    let node = new TreeNode(val);
    let index = inorder.indexOf(val);
    let left = inorder.slice(0,index);
    let right = inorder.slice(index+1);
    node.left = buildTree(preorder.slice(0,index),left);//前序数组也index前的都在左子树中
    node.right = buildTree(preorder.slice(index),right);
    return node;
};
```





## [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

         5
        / \
       2   6
      / \
     1   3

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

### 解法：

最后位置是根节点，然后从头遍历，遇到的第一个大于根节点的值下标为idx。则[0,idx-1]的是左子树，剩余的是右子树。

左子树不用检查，右子树再依次遍历查看是否都大于根节点的值，如果不大于则返回false，如果都大于则递归检查左右子树是否满足后序遍历。

```js
var verifyPostorder = function (postorder) {
    if (postorder.length <= 1) return true;
    let end = postorder.pop();
    let idx = postorder.length;//idx先设置为最后
    for (let i in postorder) {//记录第一个大于end的位置
        if (postorder[i] > end) {
            idx = i;
            break;
        }
    }
    let left = postorder.slice(0, idx);//划分左子树
    let right = postorder.slice(idx);//划分右子树
    for (let i = 0; i < right.length; i++) {//检查右子树的值是否都大于end，左子树不用检查了
        if (right[i] < end) {
            return false;
        }
    }
    return verifyPostorder(left) && verifyPostorder(right);
};
=======
## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree1.jpg" alt="img" style="zoom: 50%;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree2.jpg" alt="img" style="zoom: 50%;" />

### 思路：

[1,2,3,4,5,6,7,8]

中间的作为根节点值，左右子树则为两边内部递归

自己做法：

​```js
var sortedArrayToBST = function (nums) {
    let n = nums.length;
    if (!n) return null;
    let mid = Math.floor(n / 2);
    let tree = new TreeNode(nums[mid]);
    let left = nums.slice(0, mid);
    let right = nums.slice(mid + 1);
    tree.left = sortedArrayToBST(left);
    tree.right = sortedArrayToBST(right);
    return tree;
};
```

```js
var sortedArrayToBST = function (nums) {
    let dfs = (left, right) => {
        if (left > right) return null//说明没有元素可选了
        let tree = new TreeNode()
        let mid = Math.floor((left + right) / 2)
        tree.val = nums[mid]
        tree.left = dfs(left, mid - 1)//左子树
        tree.right = dfs(mid + 1, right)//右子树
        return tree
    }
    let tree = dfs(0, nums.length - 1)
    return tree
};
```



## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/binarytree.png" alt="img" style="zoom: 67%;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

### 思路：

根据定义，我们知道，假设 `root` 为 `p、q` 的最近公共祖先，则只可能有如下几种情况：

- p、q 在 root 的子树中，那么 p、q 分在 root 的左右子树中
- 如果 p = root，那么 q 会在 p 的左右子树中，直接返回 p 即可
- 如果 q = root，与上述类似

然后我们采用 `后序遍历`的方式，先遍历左右子树，看能不能找到对应 `p` 和 `q` 节点。

如果左右子树都能找到，那么代表p、q 分在 root 的左右子树中，直接返回 root 节点 如果左子树找到，右子树没找到，那么就返回左子树的查找结果 如果右子树找到，左子树没找到，那么就返回右子树的查找结果

<img src="https://camo.githubusercontent.com/702bfc252c95673e805fbb1d4a55684d5e9b8569320ef473e8b4f67824502c44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343138343431393638382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var lowestCommonAncestor = function (root, p, q) {
    if (!root || root == p || root == q) return root;//当前的节点为空，或者root == p || root == q则返回root
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    // 如果当前root 在左右子树下可以找到 p q 那么这个root就是它们的最近公共祖先
    if(left && right) return root; 
    // 如果当前root 只有左子树有节点，那么这个节点本身就是p、q的祖先
    else if(left) return left;
    // 如果当前root 只有右子树有节点，那么这个节点本身就是p、q的祖先
    else return right;
};
```





## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

示例:

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

### 思路：

对于这道题，我们必须先了解一下二叉搜索树（BST）的性质，如下：

BST性质

- 中序遍历是升序
- left小于当前节点，right大于当前节点
- 左子树、右子树也要是BST

了解了性质之后，我们知道要查找对应 `key` 值，可以与根节点进行比较，如果小于根节点，直接去左子树找就好了，如果大于根节点，直接去右子树找就好了。

而对于刚好等于根节点的话，我拿着大佬的图解来看看几种情况：

第一种情况，如果删除节点仅有右孩子，直接指向右孩子

<img src="https://camo.githubusercontent.com/4588e46a49f1e84644621d25252378ce5988ef0c467c644ba192ed2be57d6793/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323431363532322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第二种情况，如果删除节点仅有左孩子，直接指向左孩子

<img src="https://camo.githubusercontent.com/bf473e0d3694e56128eaba901eaad094d4af47564a48922fce32a10ed72c1d4f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303039323432323234323438392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第三种情况，如果删除节点左右孩子都有，那么我们按照题意可以有两种删除方法：

① 找到要删除节点左子树的最右边的节点，即前驱的最大值（由BST性质得到）替换当前 root 节点，然后删除这个前驱

② 找到要删除节点右子树的最左边的节点，即后继最小值（由BST性质得到）替换当前 root 节点，然后删除这个后继

<img src="https://camo.githubusercontent.com/80ff4c6af92f0ef7bed318f37033a1c276aba3d5c0224c7afd2e0e45f7d423fb/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323433303435342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var deleteNode = function (root, key) {
    if (!root) return null
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        if (!root.left && !root.right) {//要删除的节点没有左右子树
            root = null
        } else if (!root.left) {//要删除的节点没有左子树
            root = root.right
        } else if (!root.right) {//要删除的节点没有右子树
            root = root.left
        } else {//左右子树都有，使用右子树的最小值作为返回值
            let node = root.right
            while (node.left) {
                node = node.left
            }
            root.val = node.val//令root的值为右子树的最小值
            //node必是没有子树的节点，调用函数删除
            root.right = deleteNode(root.right, node.val)
        }
    }
    return root
}
```



## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给定一个有相同值的二叉搜索树（**BST**），找出 **BST** 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

```
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 思路:

由于 `BST`（二叉搜索树）的特殊性，我们采用递归来中序遍历，访问的节点值是有序的。然后重复节点，用计数器进行累加即可，如果有新值出现，则更新新值，然后计数器重置为 1。然后对于当前次数超过了最大值，则更新当前最大值，如果等于最大值，则代表出现了相同频率的数字，加入即可。

如果次数小于最大值，不需要什么操作。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    let cnt = 0;
    let pre = 0;
    let res = [];
    let maxCnt = 0;
    let handle = (cur) => {
        // 相同的数，累加
        if(cur === pre){
            cnt++;
        }else{
            // 有新数出现，重新置计数器为1，更新新数
            pre = cur;
            cnt = 1;
        }
        // 如果次数超过了最大值，更新当前最大值
        if(cnt > maxCnt){
            maxCnt = cnt;
            res = [cur];//结果也更新
        // 如果有相同频率的数字出现，直接加入
        }else if(cnt === maxCnt){
            res.push(cur);
        }
    }
    // 二叉搜索树，递归中序遍历方式
    let inOrder = (root) =>{
        if(!root) return null;
        inOrder(root.left);
        handle(root.val);
        inOrder(root.right);
    }
    inOrder(root);
    return res;
};
```





## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

### 解法：

```js
var hasPathSum = function (root, targetSum) {
    if (!root) return false
    let flag = false
    let dfs = (root, targetSum) => {
        targetSum -= root.val//先减去
        if (!root.left && !root.right) {//若当前是叶子节点
            if (targetSum === 0) {//若当前符合条件，直接返回
                flag = true
            }
            return
        }
        // 先遍历左子树，再遍历右子树
        root.left && dfs(root.left, targetSum);//有左子树才递归
        root.right && dfs(root.right, targetSum);//有右子树才递归
    }
    dfs(root, targetSum)
    return flag
}
```



## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

### 思路：

同样的思路，相比于上一题，只是要求将路径记录下来

```js
var pathSum = function (root, targetSum) {
    let res = []
    let dfs = (root, sum, arr) => {
        if (!root) return
        sum += root.val
        arr.push(root.val)
        if (!root.left && !root.right) {
            if (sum === targetSum) {
                res.push(arr)
            }
            return
        }
        root.left && dfs(root.left, sum, arr.slice())
        root.right && dfs(root.right, sum, arr.slice())
    }
    dfs(root, 0, [])
    return res
};
```



## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/pathsum3-1-tree.jpg" alt="img" style="zoom: 50%;" />

### 思路：

先序遍历每一个节点，以每一个节点为起点都执行一遍路径检查，路径检查中只要累加为target计数就+1，以叶子节点为结束标志

### 自己做法:

```js
var pathSum = function (root, targetSum) {
    let res = 0
    let judge = (root, sum) => {
        //if (!root) return;  此语句不需要了
        sum += root.val
        if (sum === targetSum) res++
        root.left && judge(root.left, sum)//在执行下一节点先判断有没有子树，递归中就不需要判断为空的条件
        root.right && judge(root.right, sum)
    }
    if (!root) return 0
    let dfs = (root) => {//每个节点为起点执行一遍judge函数
        judge(root, 0)
        root.left && dfs(root.left, 0)
        root.right && dfs(root.right, 0)
    }
    dfs(root)
    return res
}
```

### 其他做法：

```js
var pathSum = function (root, sum) {
    // 定义一个计时器
    let cnt = 0;
    // 先序遍历所有根节点
    let preOrder = (root, sum) => {
        if (root == null) return;
        dfs(root, sum);
        preOrder(root.left, sum);
        preOrder(root.right, sum);
    }
    let dfs = (root, sum) => {
        if (root == null) return;
        sum -= root.val;
        // 求和满足，累加
        if (sum === 0) cnt++;
        // 递归左右子树，如果当前和为0了，但是下面还是有路，还是继续走下去
        // 因为本题数值范围存在负数，可能继续走下去还存在满足条件的路径
        dfs(root.left, sum);
        dfs(root.right, sum);
    }
    preOrder(root, sum);
    return cnt;
};
```



## [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

示例 1:

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

### 思路：

每下降一层就假如当前记和，知道遇到叶子节点，直接加入总计数中

```js
var sumNumbers = function (root) {
    let sum = 0
    let dfs = (root, cur) => {
        cur = cur * 10 + root.val
        if (!root.left && !root.right) {//假如是叶子节点
            sum += cur
        }
        root.left && dfs(root.left, cur)
        root.right && dfs(root.right, cur)
    }
    dfs(root, 0)
    return sum
};
```





## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

示例:

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

### 解法：

```js
var binaryTreePaths = function (root) {
    let res = []
    let dfs = (root, str) => {
        if (!root.left && !root.right) {
            str += root.val + ''
            return res.push(str)
        }
        else {
            str += root.val + '->'
        }
        root.left && dfs(root.left, str)
        root.right && dfs(root.right, str)
    }
    dfs(root, '')
    return res
};
```



## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

### 解题思路:

`dfs`，求左叶子之和，叶子结点我们比较好判断，而对于左孩子，我们设置一个标记就好了，例如左孩子标记 `1`，右孩子标记 `0`，那么当且仅当是叶子节点，并且标记为 `1`（即左孩子）时，我们进行累加求和。

```js
var sumOfLeftLeaves = function (root) {
    if (!root) return 0
    let sum = 0
    let dfs = (root, cur) => {
        if (!root.left && !root.right && cur) {
            sum += root.val
            return
        }
        root.left && dfs(root.left, 1)
        root.right && dfs(root.right, 0)
    }
    dfs(root, 0)
    return sum
};
```



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
 
```

### 解法：

递归

```js
var isSymmetric = function (root) {
    if (!root) return true
    let dfs = (left, right) => {
        if (!left && !right) return true //左右子树都为空，可以
        if (!left && right) return false //左子树为空，右子树有值，不可
        if (left && !right) return false //同上
        if (left.val !== right.val) return false//若值不相等，不可
        else {
            return dfs(left.left, right.right) && dfs(left.right, right.left)//镜像判断
        }
    }
    return dfs(root.left, root.right)
};
```

迭代

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if (!root) return true
    let queue = [root.left, root.right]
    while (queue.length) {
        let node1 = queue.shift()
        let node2 = queue.shift()
        if (!node1 && !node2) continue
        if (!node1 || !node2 || node1.val !== node2.val) return false
        queue.push(node1.left)
        queue.push(node2.right)
        queue.push(node1.right)
        queue.push(node2.left)
    }
    return true
};
```

### 自己做法：

将左子树翻转再与右子树判断是否相等

```js
var isSymmetric = function (root) {
    let dfs = (root) => {//将树镜像翻转
        let temp = root.left
        root.left = root.right
        root.right = temp
        root.left && dfs(root.left)
        root.right && dfs(root.right)
    }
    let isSameTree = (p, q) => {//判断两棵树是否一样
        if (!p && !q) return true
        if (!p && q) return false
        if (p && !q) return false
        if (p.val !== q.val) return false
        else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        }
    }
    root.left && dfs(root.left)
    if (isSameTree(root.left, root.right)) return true//将左子树翻转再与右子树判断是否相等
    return false
};
```

```js
var isSymmetric = function (root) {
    if (!root) return true;
    let recur = (left, right) => {
        if(left===null && right===null) return true;
        if(!left || !right ||left.val !== right.val) return false;
        return recur(left.left,right.right) && recur(left.right,right.left);
    }
    return recur(root.left,root.right);
};
```



## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

示例 3:

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 做法：

```js
var isSameTree = function (p, q) {
    if (!p && !q) return true
    if (!p && q) return false
    if (p && !q) return false
    if (p.val !== q.val) return false
    else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```



## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

示例:

```
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
```

### 解法：

```js
var minDepth = function (root) {
    if (!root) return 0
    let minh = Number.MAX_VALUE
    let dfs = (root, h) => {
        h++
        if (!root.left && !root.right) {
            minh = h < minh ? h : minh
        }
        root.left && dfs(root.left, h)
        root.right && dfs(root.right, h)
    }
    dfs(root, 0)
    return minh
};
```





## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

### 思路：

先看右孩子，再看左孩子，若深度大于res长度，则说明可以被看到。

```js
var rightSideView = function (root) {
    if (!root) return []
    let res = []
    let dfs = (root, h) => {
        h++
        if (h > res.length) res.push(root.val)
        root.right && dfs(root.right, h)
        root.left && dfs(root.left, h)
    }
    dfs(root, 0)
    return res
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[[3], [9,20],[15,7]]
```

### 解法：

直接用 `BFS`，对于每一层初始化空数组，然后存放每一层的节点值，然后迭代即可。

```js
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let queue = [root] //开始queue的长度为1，存的是root节点
    while (queue.length) {
        let size = queue.length //当前层的节点数
        let temp = []
        while (size--) {//目的是将当前层节点的所有子节点存到queue中，方便下次迭代
            let node = queue.shift()//队首元素出队
            temp.push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        res.push(temp)
    }
    return res
};
```



## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

### 解法：

通过**后序遍历**，每一次返回当前根节点下的左右孩子的深度最大值，然后每一次递归求一下左右孩子路径和的最大值即可。

```js
var diameterOfBinaryTree = function (root) {
    if (!root) return 0;
    let res = 0;
    let dfs = (root) => {
        if (!root) return 0;
        // 后序遍历 先遍历左孩子
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 每次求直径，比较左右孩子路径和的最大值
        res = Math.max(left + right, res);
        // 递归时候返回左右孩子深度最长
        return Math.max(left, right)
    }
    dfs(root);
    return res;
};
```



## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1

示例 1:

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

示例 2:

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

### 思路：

`dfs`，平衡二叉树就是每个节点 的左右两个子树的高度差的绝对值不超过1。那么，我们可以自底向上，即采用后序遍历的方式，只要左右高度超过1了，直接设置 `flase`即可。

```js
 /**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
    if(!root) return true;
    let res = true;
    let dfs = (root) => {
        // 先遍历左子树，在遍历右子树
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 判断是否是平衡二叉树，就看高度差是否大于1
        if (Math.abs(left - right) > 1) res = false;
        // 返回左右子树深度的最大值
        return Math.max(left, right);
    }
    dfs(root);
    return res;
};
```





## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：

```
输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

示例 2：

```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```

### 思路：

后序遍历，先遍历左孩子，对于孩子的累计和，我们判断一下，如果小于0（即为负数）就没必要加了，直接返回 0 即可，否则加上孩子累计和。然后我们对每一层求一下最大值即可。

```js
var maxPathSum = function (root) {
    let max = Number.MIN_SAFE_INTEGER
    let dfs = (root) => {
        let left = root.left && dfs(root.left)
        let right = root.right && dfs(root.right)
        max = Math.max(max, left + right + root.val)//每判断一个新节点都看下左孩子和+根节点+右孩子之和是否大于最大值
        let sum = Math.max(left, right) + root.val//返回只返回最大的孩子和加根节点
        return sum > 0 ? sum : 0//假如小于0就返回0即可
    }
    dfs(root)
    return max
};
```





## [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
![image-20220410153805710](D:\前端\力扣leecode\二叉树.assets\image-20220410153805710.png)               ![image-20220410153819270](D:\前端\力扣leecode\二叉树.assets\image-20220410153819270.png)
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 解法：

```js
var isSubStructure = function (A, B) {
    let recur = (A, B) => {//判断当前节点的val是否相等
        if (!B) return true;//假如B为null,说明已经判断完毕，可以返回true
        if (!A || A.val !== B.val) return false;//假如不相等或者A都已经判定完了B还没判断完，返回false
        return recur(A.left, B.left) && recur(A.right, B.right);//当前的相等，看他们的字节点是否相等
    }
    //两个节点不能为空
    //判断A自身是否相等，不相等就递归判断左孩子，再递归判断右孩子
    return (A!==null && B!==null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
};
```





## [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

<img src="D:\前端\力扣leecode\二叉树.assets\image-20220410160729613.png" alt="image-20220410160729613"  />

### 解法：

从叶子节点先开始翻转得到镜像。如果当前遍历到的节点root的左右两棵子树都已经翻转得到镜像，那么我们只需要交换两棵子树的位置，即可得到以root 为根节点的整棵子树的镜像。

```js
var mirrorTree = function (root) {
    if(!root) return null;
    let left = mirrorTree(root.left);//让子树的左右交换，
    let right = mirrorTree(root.right);
    root.left = right;
    root.right =left;
    return root;
};
```



## [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

<img src="D:\前端\力扣leecode\二叉树.assets\bstdlloriginalbst.png" alt="img" style="zoom:33%;" />

<img src="D:\前端\力扣leecode\二叉树.assets\bstdllreturndll.png" alt="img" style="zoom:50%;" />

### 解法：

​	利用中序遍历

```js
var treeToDoublyList = function (root) {
    if (!root) return null;
    let head;
    let pre = null;

    let dfs = (root) => {
        if (!root) return;
        dfs(root.left);
        if (pre !== null) pre.right = root;//假如pre不为空，则令pre.right指向当前
        else head = root;//为空说明到了左叶子节点，为head
        root.left = pre;//当前的left指向pre
        pre = root;//中序遍历，更新pre
        dfs(root.right)
    }
    dfs(root);
    head.left = pre;
    pre.right = head;//退出时，pre指向右孩子节点
    return head
};
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

 **示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

### 解法：

中序遍历，计数

```js
var kthLargest = function (root, k) {//k大==n-k+1小
    let idx = 0;
    let v = 0;
    let dfs = (root) => {
        if (!root) return;
        dfs(root.right);
        if(idx === k)  return;//提前返回
        idx++;
        if (idx === k) {
            v =root.val
            return;
        }
        dfs(root.left);
    }
    dfs(root);
    return v;
};
```



## [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

示例 1:

<img src="D:\前端\力扣leecode\二叉树.assets\tree.jpg" alt="img" style="zoom: 50%;" />

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

### 解法：

 // 前序第一个元素  将中序分成左树 与右树
// 取出前序第一个元素做当前树根节点
// 绑定分治左树右树
// 返回当前节点节点

```js
var buildTree = function(preorder, inorder) {
    if(preorder.length <= 0) return null
    let val = preorder.shift();
    let node = new TreeNode(val);
    let index = inorder.indexOf(val);
    let left = inorder.slice(0,index);
    let right = inorder.slice(index+1);
    node.left = buildTree(preorder.slice(0,index),left);//前序数组也index前的都在左子树中
    node.right = buildTree(preorder.slice(index),right);
    return node;
};
```





## [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

         5
        / \
       2   6
      / \
     1   3

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

### 解法：

最后位置是根节点，然后从头遍历，遇到的第一个大于根节点的值下标为idx。则[0,idx-1]的是左子树，剩余的是右子树。

左子树不用检查，右子树再依次遍历查看是否都大于根节点的值，如果不大于则返回false，如果都大于则递归检查左右子树是否满足后序遍历。

```js
var verifyPostorder = function (postorder) {
    if (postorder.length <= 1) return true;
    let end = postorder.pop();
    let idx = postorder.length;//idx先设置为最后
    for (let i in postorder) {//记录第一个大于end的位置
        if (postorder[i] > end) {
            idx = i;
            break;
        }
    }
    let left = postorder.slice(0, idx);//划分左子树
    let right = postorder.slice(idx);//划分右子树
    for (let i = 0; i < right.length; i++) {//检查右子树的值是否都大于end，左子树不用检查了
        if (right[i] < end) {
            return false;
        }
    }
    return verifyPostorder(left) && verifyPostorder(right);
};
>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree1.jpg" alt="img" style="zoom: 50%;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree2.jpg" alt="img" style="zoom: 50%;" />

### 思路：

[1,2,3,4,5,6,7,8]

中间的作为根节点值，左右子树则为两边内部递归

自己做法：

​```js
var sortedArrayToBST = function (nums) {
    let n = nums.length;
    if (!n) return null;
    let mid = Math.floor(n / 2);
    let tree = new TreeNode(nums[mid]);
    let left = nums.slice(0, mid);
    let right = nums.slice(mid + 1);
    tree.left = sortedArrayToBST(left);
    tree.right = sortedArrayToBST(right);
    return tree;
};
```

```js
var sortedArrayToBST = function (nums) {
    let dfs = (left, right) => {
        if (left > right) return null//说明没有元素可选了
        let tree = new TreeNode()
        let mid = Math.floor((left + right) / 2)
        tree.val = nums[mid]
        tree.left = dfs(left, mid - 1)//左子树
        tree.right = dfs(mid + 1, right)//右子树
        return tree
    }
    let tree = dfs(0, nums.length - 1)
    return tree
};
```



## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/binarytree.png" alt="img" style="zoom: 67%;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

### 思路：

根据定义，我们知道，假设 `root` 为 `p、q` 的最近公共祖先，则只可能有如下几种情况：

- p、q 在 root 的子树中，那么 p、q 分在 root 的左右子树中
- 如果 p = root，那么 q 会在 p 的左右子树中，直接返回 p 即可
- 如果 q = root，与上述类似

然后我们采用 `后序遍历`的方式，先遍历左右子树，看能不能找到对应 `p` 和 `q` 节点。

如果左右子树都能找到，那么代表p、q 分在 root 的左右子树中，直接返回 root 节点 如果左子树找到，右子树没找到，那么就返回左子树的查找结果 如果右子树找到，左子树没找到，那么就返回右子树的查找结果

<img src="https://camo.githubusercontent.com/702bfc252c95673e805fbb1d4a55684d5e9b8569320ef473e8b4f67824502c44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343138343431393638382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var lowestCommonAncestor = function (root, p, q) {
    if (!root || root == p || root == q) return root;//当前的节点为空，或者root == p || root == q则返回root
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    // 如果当前root 在左右子树下可以找到 p q 那么这个root就是它们的最近公共祖先
    if(left && right) return root; 
    // 如果当前root 只有左子树有节点，那么这个节点本身就是p、q的祖先
    else if(left) return left;
    // 如果当前root 只有右子树有节点，那么这个节点本身就是p、q的祖先
    else return right;
};
```





## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

示例:

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

### 思路：

对于这道题，我们必须先了解一下二叉搜索树（BST）的性质，如下：

BST性质

- 中序遍历是升序
- left小于当前节点，right大于当前节点
- 左子树、右子树也要是BST

了解了性质之后，我们知道要查找对应 `key` 值，可以与根节点进行比较，如果小于根节点，直接去左子树找就好了，如果大于根节点，直接去右子树找就好了。

而对于刚好等于根节点的话，我拿着大佬的图解来看看几种情况：

第一种情况，如果删除节点仅有右孩子，直接指向右孩子

<img src="https://camo.githubusercontent.com/4588e46a49f1e84644621d25252378ce5988ef0c467c644ba192ed2be57d6793/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323431363532322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第二种情况，如果删除节点仅有左孩子，直接指向左孩子

<img src="https://camo.githubusercontent.com/bf473e0d3694e56128eaba901eaad094d4af47564a48922fce32a10ed72c1d4f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303039323432323234323438392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第三种情况，如果删除节点左右孩子都有，那么我们按照题意可以有两种删除方法：

① 找到要删除节点左子树的最右边的节点，即前驱的最大值（由BST性质得到）替换当前 root 节点，然后删除这个前驱

② 找到要删除节点右子树的最左边的节点，即后继最小值（由BST性质得到）替换当前 root 节点，然后删除这个后继

<img src="https://camo.githubusercontent.com/80ff4c6af92f0ef7bed318f37033a1c276aba3d5c0224c7afd2e0e45f7d423fb/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323433303435342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var deleteNode = function (root, key) {
    if (!root) return null
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        if (!root.left && !root.right) {//要删除的节点没有左右子树
            root = null
        } else if (!root.left) {//要删除的节点没有左子树
            root = root.right
        } else if (!root.right) {//要删除的节点没有右子树
            root = root.left
        } else {//左右子树都有，使用右子树的最小值作为返回值
            let node = root.right
            while (node.left) {
                node = node.left
            }
            root.val = node.val//令root的值为右子树的最小值
            //node必是没有子树的节点，调用函数删除
            root.right = deleteNode(root.right, node.val)
        }
    }
    return root
}
```



## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给定一个有相同值的二叉搜索树（**BST**），找出 **BST** 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

```
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 思路:

由于 `BST`（二叉搜索树）的特殊性，我们采用递归来中序遍历，访问的节点值是有序的。然后重复节点，用计数器进行累加即可，如果有新值出现，则更新新值，然后计数器重置为 1。然后对于当前次数超过了最大值，则更新当前最大值，如果等于最大值，则代表出现了相同频率的数字，加入即可。

如果次数小于最大值，不需要什么操作。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    let cnt = 0;
    let pre = 0;
    let res = [];
    let maxCnt = 0;
    let handle = (cur) => {
        // 相同的数，累加
        if(cur === pre){
            cnt++;
        }else{
            // 有新数出现，重新置计数器为1，更新新数
            pre = cur;
            cnt = 1;
        }
        // 如果次数超过了最大值，更新当前最大值
        if(cnt > maxCnt){
            maxCnt = cnt;
            res = [cur];//结果也更新
        // 如果有相同频率的数字出现，直接加入
        }else if(cnt === maxCnt){
            res.push(cur);
        }
    }
    // 二叉搜索树，递归中序遍历方式
    let inOrder = (root) =>{
        if(!root) return null;
        inOrder(root.left);
        handle(root.val);
        inOrder(root.right);
    }
    inOrder(root);
    return res;
};
```





## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

### 解法：

```js
var hasPathSum = function (root, targetSum) {
    if (!root) return false
    let flag = false
    let dfs = (root, targetSum) => {
        targetSum -= root.val//先减去
        if (!root.left && !root.right) {//若当前是叶子节点
            if (targetSum === 0) {//若当前符合条件，直接返回
                flag = true
            }
            return
        }
        // 先遍历左子树，再遍历右子树
        root.left && dfs(root.left, targetSum);//有左子树才递归
        root.right && dfs(root.right, targetSum);//有右子树才递归
    }
    dfs(root, targetSum)
    return flag
}
```



## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

### 思路：

同样的思路，相比于上一题，只是要求将路径记录下来

```js
var pathSum = function (root, targetSum) {
    let res = []
    let dfs = (root, sum, arr) => {
        if (!root) return
        sum += root.val
        arr.push(root.val)
        if (!root.left && !root.right) {
            if (sum === targetSum) {
                res.push(arr)
            }
            return
        }
        root.left && dfs(root.left, sum, arr.slice())
        root.right && dfs(root.right, sum, arr.slice())
    }
    dfs(root, 0, [])
    return res
};
```



## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/pathsum3-1-tree.jpg" alt="img" style="zoom: 50%;" />

### 思路：

先序遍历每一个节点，以每一个节点为起点都执行一遍路径检查，路径检查中只要累加为target计数就+1，以叶子节点为结束标志

### 自己做法:

```js
var pathSum = function (root, targetSum) {
    let res = 0
    let judge = (root, sum) => {
        //if (!root) return;  此语句不需要了
        sum += root.val
        if (sum === targetSum) res++
        root.left && judge(root.left, sum)//在执行下一节点先判断有没有子树，递归中就不需要判断为空的条件
        root.right && judge(root.right, sum)
    }
    if (!root) return 0
    let dfs = (root) => {//每个节点为起点执行一遍judge函数
        judge(root, 0)
        root.left && dfs(root.left, 0)
        root.right && dfs(root.right, 0)
    }
    dfs(root)
    return res
}
```

### 其他做法：

```js
var pathSum = function (root, sum) {
    // 定义一个计时器
    let cnt = 0;
    // 先序遍历所有根节点
    let preOrder = (root, sum) => {
        if (root == null) return;
        dfs(root, sum);
        preOrder(root.left, sum);
        preOrder(root.right, sum);
    }
    let dfs = (root, sum) => {
        if (root == null) return;
        sum -= root.val;
        // 求和满足，累加
        if (sum === 0) cnt++;
        // 递归左右子树，如果当前和为0了，但是下面还是有路，还是继续走下去
        // 因为本题数值范围存在负数，可能继续走下去还存在满足条件的路径
        dfs(root.left, sum);
        dfs(root.right, sum);
    }
    preOrder(root, sum);
    return cnt;
};
```



## [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

示例 1:

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

### 思路：

每下降一层就假如当前记和，知道遇到叶子节点，直接加入总计数中

```js
var sumNumbers = function (root) {
    let sum = 0
    let dfs = (root, cur) => {
        cur = cur * 10 + root.val
        if (!root.left && !root.right) {//假如是叶子节点
            sum += cur
        }
        root.left && dfs(root.left, cur)
        root.right && dfs(root.right, cur)
    }
    dfs(root, 0)
    return sum
};
```





## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

示例:

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

### 解法：

```js
var binaryTreePaths = function (root) {
    let res = []
    let dfs = (root, str) => {
        if (!root.left && !root.right) {
            str += root.val + ''
            return res.push(str)
        }
        else {
            str += root.val + '->'
        }
        root.left && dfs(root.left, str)
        root.right && dfs(root.right, str)
    }
    dfs(root, '')
    return res
};
```



## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

### 解题思路:

`dfs`，求左叶子之和，叶子结点我们比较好判断，而对于左孩子，我们设置一个标记就好了，例如左孩子标记 `1`，右孩子标记 `0`，那么当且仅当是叶子节点，并且标记为 `1`（即左孩子）时，我们进行累加求和。

```js
var sumOfLeftLeaves = function (root) {
    if (!root) return 0
    let sum = 0
    let dfs = (root, cur) => {
        if (!root.left && !root.right && cur) {
            sum += root.val
            return
        }
        root.left && dfs(root.left, 1)
        root.right && dfs(root.right, 0)
    }
    dfs(root, 0)
    return sum
};
```



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
 
```

### 解法：

递归

```js
var isSymmetric = function (root) {
    if (!root) return true
    let dfs = (left, right) => {
        if (!left && !right) return true //左右子树都为空，可以
        if (!left && right) return false //左子树为空，右子树有值，不可
        if (left && !right) return false //同上
        if (left.val !== right.val) return false//若值不相等，不可
        else {
            return dfs(left.left, right.right) && dfs(left.right, right.left)//镜像判断
        }
    }
    return dfs(root.left, root.right)
};
```

迭代

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if (!root) return true
    let queue = [root.left, root.right]
    while (queue.length) {
        let node1 = queue.shift()
        let node2 = queue.shift()
        if (!node1 && !node2) continue
        if (!node1 || !node2 || node1.val !== node2.val) return false
        queue.push(node1.left)
        queue.push(node2.right)
        queue.push(node1.right)
        queue.push(node2.left)
    }
    return true
};
```

### 自己做法：

将左子树翻转再与右子树判断是否相等

```js
var isSymmetric = function (root) {
    let dfs = (root) => {//将树镜像翻转
        let temp = root.left
        root.left = root.right
        root.right = temp
        root.left && dfs(root.left)
        root.right && dfs(root.right)
    }
    let isSameTree = (p, q) => {//判断两棵树是否一样
        if (!p && !q) return true
        if (!p && q) return false
        if (p && !q) return false
        if (p.val !== q.val) return false
        else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        }
    }
    root.left && dfs(root.left)
    if (isSameTree(root.left, root.right)) return true//将左子树翻转再与右子树判断是否相等
    return false
};
```

```js
var isSymmetric = function (root) {
    if (!root) return true;
    let recur = (left, right) => {
        if(left===null && right===null) return true;
        if(!left || !right ||left.val !== right.val) return false;
        return recur(left.left,right.right) && recur(left.right,right.left);
    }
    return recur(root.left,root.right);
};
```



## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

示例 3:

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 做法：

```js
var isSameTree = function (p, q) {
    if (!p && !q) return true
    if (!p && q) return false
    if (p && !q) return false
    if (p.val !== q.val) return false
    else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```



## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

示例:

```
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
```

### 解法：

```js
var minDepth = function (root) {
    if (!root) return 0
    let minh = Number.MAX_VALUE
    let dfs = (root, h) => {
        h++
        if (!root.left && !root.right) {
            minh = h < minh ? h : minh
        }
        root.left && dfs(root.left, h)
        root.right && dfs(root.right, h)
    }
    dfs(root, 0)
    return minh
};
```





## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

### 思路：

先看右孩子，再看左孩子，若深度大于res长度，则说明可以被看到。

```js
var rightSideView = function (root) {
    if (!root) return []
    let res = []
    let dfs = (root, h) => {
        h++
        if (h > res.length) res.push(root.val)
        root.right && dfs(root.right, h)
        root.left && dfs(root.left, h)
    }
    dfs(root, 0)
    return res
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[[3], [9,20],[15,7]]
```

### 解法：

直接用 `BFS`，对于每一层初始化空数组，然后存放每一层的节点值，然后迭代即可。

```js
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let queue = [root] //开始queue的长度为1，存的是root节点
    while (queue.length) {
        let size = queue.length //当前层的节点数
        let temp = []
        while (size--) {//目的是将当前层节点的所有子节点存到queue中，方便下次迭代
            let node = queue.shift()//队首元素出队
            temp.push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        res.push(temp)
    }
    return res
};
```



## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

### 解法：

通过**后序遍历**，每一次返回当前根节点下的左右孩子的深度最大值，然后每一次递归求一下左右孩子路径和的最大值即可。

```js
var diameterOfBinaryTree = function (root) {
    if (!root) return 0;
    let res = 0;
    let dfs = (root) => {
        if (!root) return 0;
        // 后序遍历 先遍历左孩子
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 每次求直径，比较左右孩子路径和的最大值
        res = Math.max(left + right, res);
        // 递归时候返回左右孩子深度最长
        return Math.max(left, right)
    }
    dfs(root);
    return res;
};
```



## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1

示例 1:

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

示例 2:

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

### 思路：

`dfs`，平衡二叉树就是每个节点 的左右两个子树的高度差的绝对值不超过1。那么，我们可以自底向上，即采用后序遍历的方式，只要左右高度超过1了，直接设置 `flase`即可。

```js
 /**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
    if(!root) return true;
    let res = true;
    let dfs = (root) => {
        // 先遍历左子树，在遍历右子树
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 判断是否是平衡二叉树，就看高度差是否大于1
        if (Math.abs(left - right) > 1) res = false;
        // 返回左右子树深度的最大值
        return Math.max(left, right);
    }
    dfs(root);
    return res;
};
```





## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：

```
输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

示例 2：

```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```

### 思路：

后序遍历，先遍历左孩子，对于孩子的累计和，我们判断一下，如果小于0（即为负数）就没必要加了，直接返回 0 即可，否则加上孩子累计和。然后我们对每一层求一下最大值即可。

```js
var maxPathSum = function (root) {
    let max = Number.MIN_SAFE_INTEGER
    let dfs = (root) => {
        let left = root.left && dfs(root.left)
        let right = root.right && dfs(root.right)
        max = Math.max(max, left + right + root.val)//每判断一个新节点都看下左孩子和+根节点+右孩子之和是否大于最大值
        let sum = Math.max(left, right) + root.val//返回只返回最大的孩子和加根节点
        return sum > 0 ? sum : 0//假如小于0就返回0即可
    }
    dfs(root)
    return max
};
```





## [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
![image-20220410153805710](D:\前端\力扣leecode\二叉树.assets\image-20220410153805710.png)               ![image-20220410153819270](D:\前端\力扣leecode\二叉树.assets\image-20220410153819270.png)
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 解法：

```js
var isSubStructure = function (A, B) {
    let recur = (A, B) => {//判断当前节点的val是否相等
        if (!B) return true;//假如B为null,说明已经判断完毕，可以返回true
        if (!A || A.val !== B.val) return false;//假如不相等或者A都已经判定完了B还没判断完，返回false
        return recur(A.left, B.left) && recur(A.right, B.right);//当前的相等，看他们的字节点是否相等
    }
    //两个节点不能为空
    //判断A自身是否相等，不相等就递归判断左孩子，再递归判断右孩子
    return (A!==null && B!==null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
};
```





## [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

<img src="D:\前端\力扣leecode\二叉树.assets\image-20220410160729613.png" alt="image-20220410160729613"  />

### 解法：

从叶子节点先开始翻转得到镜像。如果当前遍历到的节点root的左右两棵子树都已经翻转得到镜像，那么我们只需要交换两棵子树的位置，即可得到以root 为根节点的整棵子树的镜像。

```js
var mirrorTree = function (root) {
    if(!root) return null;
    let left = mirrorTree(root.left);//让子树的左右交换，
    let right = mirrorTree(root.right);
    root.left = right;
    root.right =left;
    return root;
};
```



## [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

<img src="D:\前端\力扣leecode\二叉树.assets\bstdlloriginalbst.png" alt="img" style="zoom:33%;" />

<img src="D:\前端\力扣leecode\二叉树.assets\bstdllreturndll.png" alt="img" style="zoom:50%;" />

### 解法：

​	利用中序遍历

```js
var treeToDoublyList = function (root) {
    if (!root) return null;
    let head;
    let pre = null;

    let dfs = (root) => {
        if (!root) return;
        dfs(root.left);
        if (pre !== null) pre.right = root;//假如pre不为空，则令pre.right指向当前
        else head = root;//为空说明到了左叶子节点，为head
        root.left = pre;//当前的left指向pre
        pre = root;//中序遍历，更新pre
        dfs(root.right)
    }
    dfs(root);
    head.left = pre;
    pre.right = head;//退出时，pre指向右孩子节点
    return head
};
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

 **示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

### 解法：

中序遍历，计数

```js
var kthLargest = function (root, k) {//k大==n-k+1小
    let idx = 0;
    let v = 0;
    let dfs = (root) => {
        if (!root) return;
        dfs(root.right);
        if(idx === k)  return;//提前返回
        idx++;
        if (idx === k) {
            v =root.val
            return;
        }
        dfs(root.left);
    }
    dfs(root);
    return v;
};
```



## [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

示例 1:

<img src="D:\前端\力扣leecode\二叉树.assets\tree.jpg" alt="img" style="zoom: 50%;" />

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

### 解法：

 // 前序第一个元素  将中序分成左树 与右树
// 取出前序第一个元素做当前树根节点
// 绑定分治左树右树
// 返回当前节点节点

```js
var buildTree = function(preorder, inorder) {
    if(preorder.length <= 0) return null
    let val = preorder.shift();
    let node = new TreeNode(val);
    let index = inorder.indexOf(val);
    let left = inorder.slice(0,index);
    let right = inorder.slice(index+1);
    node.left = buildTree(preorder.slice(0,index),left);//前序数组也index前的都在左子树中
    node.right = buildTree(preorder.slice(index),right);
    return node;
};
```





## [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

         5
        / \
       2   6
      / \
     1   3

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

### 解法：

最后位置是根节点，然后从头遍历，遇到的第一个大于根节点的值下标为idx。则[0,idx-1]的是左子树，剩余的是右子树。

左子树不用检查，右子树再依次遍历查看是否都大于根节点的值，如果不大于则返回false，如果都大于则递归检查左右子树是否满足后序遍历。

```js
var verifyPostorder = function (postorder) {
    if (postorder.length <= 1) return true;
    let end = postorder.pop();
    let idx = postorder.length;//idx先设置为最后
    for (let i in postorder) {//记录第一个大于end的位置
        if (postorder[i] > end) {
            idx = i;
            break;
        }
    }
    let left = postorder.slice(0, idx);//划分左子树
    let right = postorder.slice(idx);//划分右子树
    for (let i = 0; i < right.length; i++) {//检查右子树的值是否都大于end，左子树不用检查了
        if (right[i] < end) {
            return false;
        }
    }
    return verifyPostorder(left) && verifyPostorder(right);
};
>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree1.jpg" alt="img" style="zoom: 50%;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/btree2.jpg" alt="img" style="zoom: 50%;" />

### 思路：

[1,2,3,4,5,6,7,8]

中间的作为根节点值，左右子树则为两边内部递归

自己做法：

​```js
var sortedArrayToBST = function (nums) {
    let n = nums.length;
    if (!n) return null;
    let mid = Math.floor(n / 2);
    let tree = new TreeNode(nums[mid]);
    let left = nums.slice(0, mid);
    let right = nums.slice(mid + 1);
    tree.left = sortedArrayToBST(left);
    tree.right = sortedArrayToBST(right);
    return tree;
};
```

```js
var sortedArrayToBST = function (nums) {
    let dfs = (left, right) => {
        if (left > right) return null//说明没有元素可选了
        let tree = new TreeNode()
        let mid = Math.floor((left + right) / 2)
        tree.val = nums[mid]
        tree.left = dfs(left, mid - 1)//左子树
        tree.right = dfs(mid + 1, right)//右子树
        return tree
    }
    let tree = dfs(0, nums.length - 1)
    return tree
};
```



## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

示例 1：

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/binarytree.png" alt="img" style="zoom: 67%;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

### 思路：

根据定义，我们知道，假设 `root` 为 `p、q` 的最近公共祖先，则只可能有如下几种情况：

- p、q 在 root 的子树中，那么 p、q 分在 root 的左右子树中
- 如果 p = root，那么 q 会在 p 的左右子树中，直接返回 p 即可
- 如果 q = root，与上述类似

然后我们采用 `后序遍历`的方式，先遍历左右子树，看能不能找到对应 `p` 和 `q` 节点。

如果左右子树都能找到，那么代表p、q 分在 root 的左右子树中，直接返回 root 节点 如果左子树找到，右子树没找到，那么就返回左子树的查找结果 如果右子树找到，左子树没找到，那么就返回右子树的查找结果

<img src="https://camo.githubusercontent.com/702bfc252c95673e805fbb1d4a55684d5e9b8569320ef473e8b4f67824502c44/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343138343431393638382e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var lowestCommonAncestor = function (root, p, q) {
    if (!root || root == p || root == q) return root;//当前的节点为空，或者root == p || root == q则返回root
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    // 如果当前root 在左右子树下可以找到 p q 那么这个root就是它们的最近公共祖先
    if(left && right) return root; 
    // 如果当前root 只有左子树有节点，那么这个节点本身就是p、q的祖先
    else if(left) return left;
    // 如果当前root 只有右子树有节点，那么这个节点本身就是p、q的祖先
    else return right;
};
```





## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

示例:

```
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7
```

### 思路：

对于这道题，我们必须先了解一下二叉搜索树（BST）的性质，如下：

BST性质

- 中序遍历是升序
- left小于当前节点，right大于当前节点
- 左子树、右子树也要是BST

了解了性质之后，我们知道要查找对应 `key` 值，可以与根节点进行比较，如果小于根节点，直接去左子树找就好了，如果大于根节点，直接去右子树找就好了。

而对于刚好等于根节点的话，我拿着大佬的图解来看看几种情况：

第一种情况，如果删除节点仅有右孩子，直接指向右孩子

<img src="https://camo.githubusercontent.com/4588e46a49f1e84644621d25252378ce5988ef0c467c644ba192ed2be57d6793/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323431363532322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第二种情况，如果删除节点仅有左孩子，直接指向左孩子

<img src="https://camo.githubusercontent.com/bf473e0d3694e56128eaba901eaad094d4af47564a48922fce32a10ed72c1d4f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303039323432323234323438392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

第三种情况，如果删除节点左右孩子都有，那么我们按照题意可以有两种删除方法：

① 找到要删除节点左子树的最右边的节点，即前驱的最大值（由BST性质得到）替换当前 root 节点，然后删除这个前驱

② 找到要删除节点右子树的最左边的节点，即后继最小值（由BST性质得到）替换当前 root 节点，然后删除这个后继

<img src="https://camo.githubusercontent.com/80ff4c6af92f0ef7bed318f37033a1c276aba3d5c0224c7afd2e0e45f7d423fb/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343232323433303435342e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var deleteNode = function (root, key) {
    if (!root) return null
    if (key < root.val) {
        root.left = deleteNode(root.left, key);
    } else if (key > root.val) {
        root.right = deleteNode(root.right, key);
    } else {
        if (!root.left && !root.right) {//要删除的节点没有左右子树
            root = null
        } else if (!root.left) {//要删除的节点没有左子树
            root = root.right
        } else if (!root.right) {//要删除的节点没有右子树
            root = root.left
        } else {//左右子树都有，使用右子树的最小值作为返回值
            let node = root.right
            while (node.left) {
                node = node.left
            }
            root.val = node.val//令root的值为右子树的最小值
            //node必是没有子树的节点，调用函数删除
            root.right = deleteNode(root.right, node.val)
        }
    }
    return root
}
```



## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

给定一个有相同值的二叉搜索树（**BST**），找出 **BST** 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

```
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].
```

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 思路:

由于 `BST`（二叉搜索树）的特殊性，我们采用递归来中序遍历，访问的节点值是有序的。然后重复节点，用计数器进行累加即可，如果有新值出现，则更新新值，然后计数器重置为 1。然后对于当前次数超过了最大值，则更新当前最大值，如果等于最大值，则代表出现了相同频率的数字，加入即可。

如果次数小于最大值，不需要什么操作。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var findMode = function(root) {
    let cnt = 0;
    let pre = 0;
    let res = [];
    let maxCnt = 0;
    let handle = (cur) => {
        // 相同的数，累加
        if(cur === pre){
            cnt++;
        }else{
            // 有新数出现，重新置计数器为1，更新新数
            pre = cur;
            cnt = 1;
        }
        // 如果次数超过了最大值，更新当前最大值
        if(cnt > maxCnt){
            maxCnt = cnt;
            res = [cur];//结果也更新
        // 如果有相同频率的数字出现，直接加入
        }else if(cnt === maxCnt){
            res.push(cur);
        }
    }
    // 二叉搜索树，递归中序遍历方式
    let inOrder = (root) =>{
        if(!root) return null;
        inOrder(root.left);
        handle(root.val);
        inOrder(root.right);
    }
    inOrder(root);
    return res;
};
```





## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

### 解法：

```js
var hasPathSum = function (root, targetSum) {
    if (!root) return false
    let flag = false
    let dfs = (root, targetSum) => {
        targetSum -= root.val//先减去
        if (!root.left && !root.right) {//若当前是叶子节点
            if (targetSum === 0) {//若当前符合条件，直接返回
                flag = true
            }
            return
        }
        // 先遍历左子树，再遍历右子树
        root.left && dfs(root.left, targetSum);//有左子树才递归
        root.right && dfs(root.right, targetSum);//有右子树才递归
    }
    dfs(root, targetSum)
    return flag
}
```



## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

示例 1：

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：[[5,4,11,2],[5,8,4,5]]

示例:

```
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

### 思路：

同样的思路，相比于上一题，只是要求将路径记录下来

```js
var pathSum = function (root, targetSum) {
    let res = []
    let dfs = (root, sum, arr) => {
        if (!root) return
        sum += root.val
        arr.push(root.val)
        if (!root.left && !root.right) {
            if (sum === targetSum) {
                res.push(arr)
            }
            return
        }
        root.left && dfs(root.left, sum, arr.slice())
        root.right && dfs(root.right, sum, arr.slice())
    }
    dfs(root, 0, [])
    return res
};
```



## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

<img src="%E4%BA%8C%E5%8F%89%E6%A0%91.assets/pathsum3-1-tree.jpg" alt="img" style="zoom: 50%;" />

### 思路：

先序遍历每一个节点，以每一个节点为起点都执行一遍路径检查，路径检查中只要累加为target计数就+1，以叶子节点为结束标志

### 自己做法:

```js
var pathSum = function (root, targetSum) {
    let res = 0
    let judge = (root, sum) => {
        //if (!root) return;  此语句不需要了
        sum += root.val
        if (sum === targetSum) res++
        root.left && judge(root.left, sum)//在执行下一节点先判断有没有子树，递归中就不需要判断为空的条件
        root.right && judge(root.right, sum)
    }
    if (!root) return 0
    let dfs = (root) => {//每个节点为起点执行一遍judge函数
        judge(root, 0)
        root.left && dfs(root.left, 0)
        root.right && dfs(root.right, 0)
    }
    dfs(root)
    return res
}
```

### 其他做法：

```js
var pathSum = function (root, sum) {
    // 定义一个计时器
    let cnt = 0;
    // 先序遍历所有根节点
    let preOrder = (root, sum) => {
        if (root == null) return;
        dfs(root, sum);
        preOrder(root.left, sum);
        preOrder(root.right, sum);
    }
    let dfs = (root, sum) => {
        if (root == null) return;
        sum -= root.val;
        // 求和满足，累加
        if (sum === 0) cnt++;
        // 递归左右子树，如果当前和为0了，但是下面还是有路，还是继续走下去
        // 因为本题数值范围存在负数，可能继续走下去还存在满足条件的路径
        dfs(root.left, sum);
        dfs(root.right, sum);
    }
    preOrder(root, sum);
    return cnt;
};
```



## [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

示例 1:

```
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

### 思路：

每下降一层就假如当前记和，知道遇到叶子节点，直接加入总计数中

```js
var sumNumbers = function (root) {
    let sum = 0
    let dfs = (root, cur) => {
        cur = cur * 10 + root.val
        if (!root.left && !root.right) {//假如是叶子节点
            sum += cur
        }
        root.left && dfs(root.left, cur)
        root.right && dfs(root.right, cur)
    }
    dfs(root, 0)
    return sum
};
```





## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

示例:

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

### 解法：

```js
var binaryTreePaths = function (root) {
    let res = []
    let dfs = (root, str) => {
        if (!root.left && !root.right) {
            str += root.val + ''
            return res.push(str)
        }
        else {
            str += root.val + '->'
        }
        root.left && dfs(root.left, str)
        root.right && dfs(root.right, str)
    }
    dfs(root, '')
    return res
};
```



## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

计算给定二叉树的所有左叶子之和。

**示例：**

```
    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

### 解题思路:

`dfs`，求左叶子之和，叶子结点我们比较好判断，而对于左孩子，我们设置一个标记就好了，例如左孩子标记 `1`，右孩子标记 `0`，那么当且仅当是叶子节点，并且标记为 `1`（即左孩子）时，我们进行累加求和。

```js
var sumOfLeftLeaves = function (root) {
    if (!root) return 0
    let sum = 0
    let dfs = (root, cur) => {
        if (!root.left && !root.right && cur) {
            sum += root.val
            return
        }
        root.left && dfs(root.left, 1)
        root.right && dfs(root.right, 0)
    }
    dfs(root, 0)
    return sum
};
```



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
 
```

### 解法：

递归

```js
var isSymmetric = function (root) {
    if (!root) return true
    let dfs = (left, right) => {
        if (!left && !right) return true //左右子树都为空，可以
        if (!left && right) return false //左子树为空，右子树有值，不可
        if (left && !right) return false //同上
        if (left.val !== right.val) return false//若值不相等，不可
        else {
            return dfs(left.left, right.right) && dfs(left.right, right.left)//镜像判断
        }
    }
    return dfs(root.left, root.right)
};
```

迭代

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if (!root) return true
    let queue = [root.left, root.right]
    while (queue.length) {
        let node1 = queue.shift()
        let node2 = queue.shift()
        if (!node1 && !node2) continue
        if (!node1 || !node2 || node1.val !== node2.val) return false
        queue.push(node1.left)
        queue.push(node2.right)
        queue.push(node1.right)
        queue.push(node2.left)
    }
    return true
};
```

### 自己做法：

将左子树翻转再与右子树判断是否相等

```js
var isSymmetric = function (root) {
    let dfs = (root) => {//将树镜像翻转
        let temp = root.left
        root.left = root.right
        root.right = temp
        root.left && dfs(root.left)
        root.right && dfs(root.right)
    }
    let isSameTree = (p, q) => {//判断两棵树是否一样
        if (!p && !q) return true
        if (!p && q) return false
        if (p && !q) return false
        if (p.val !== q.val) return false
        else {
            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
        }
    }
    root.left && dfs(root.left)
    if (isSameTree(root.left, root.right)) return true//将左子树翻转再与右子树判断是否相等
    return false
};
```

```js
var isSymmetric = function (root) {
    if (!root) return true;
    let recur = (left, right) => {
        if(left===null && right===null) return true;
        if(!left || !right ||left.val !== right.val) return false;
        return recur(left.left,right.right) && recur(left.right,right.left);
    }
    return recur(root.left,root.right);
};
```



## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

示例 2:

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

示例 3:

```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

### 做法：

```js
var isSameTree = function (p, q) {
    if (!p && !q) return true
    if (!p && q) return false
    if (p && !q) return false
    if (p.val !== q.val) return false
    else {
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
    }
};
```



## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

示例:

```
给定二叉树 [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
```

### 解法：

```js
var minDepth = function (root) {
    if (!root) return 0
    let minh = Number.MAX_VALUE
    let dfs = (root, h) => {
        h++
        if (!root.left && !root.right) {
            minh = h < minh ? h : minh
        }
        root.left && dfs(root.left, h)
        root.right && dfs(root.right, h)
    }
    dfs(root, 0)
    return minh
};
```





## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

```
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
```

### 思路：

先看右孩子，再看左孩子，若深度大于res长度，则说明可以被看到。

```js
var rightSideView = function (root) {
    if (!root) return []
    let res = []
    let dfs = (root, h) => {
        h++
        if (h > res.length) res.push(root.val)
        root.right && dfs(root.right, h)
        root.left && dfs(root.left, h)
    }
    dfs(root, 0)
    return res
};
```



## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

示例：

```
二叉树：[3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[[3], [9,20],[15,7]]
```

### 解法：

直接用 `BFS`，对于每一层初始化空数组，然后存放每一层的节点值，然后迭代即可。

```js
var levelOrder = function (root) {
    if (!root) return []
    let res = []
    let queue = [root] //开始queue的长度为1，存的是root节点
    while (queue.length) {
        let size = queue.length //当前层的节点数
        let temp = []
        while (size--) {//目的是将当前层节点的所有子节点存到queue中，方便下次迭代
            let node = queue.shift()//队首元素出队
            temp.push(node.val)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        res.push(temp)
    }
    return res
};
```



## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。

### 解法：

通过**后序遍历**，每一次返回当前根节点下的左右孩子的深度最大值，然后每一次递归求一下左右孩子路径和的最大值即可。

```js
var diameterOfBinaryTree = function (root) {
    if (!root) return 0;
    let res = 0;
    let dfs = (root) => {
        if (!root) return 0;
        // 后序遍历 先遍历左孩子
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 每次求直径，比较左右孩子路径和的最大值
        res = Math.max(left + right, res);
        // 递归时候返回左右孩子深度最长
        return Math.max(left, right)
    }
    dfs(root);
    return res;
};
```



## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1

示例 1:

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

示例 2:

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

### 思路：

`dfs`，平衡二叉树就是每个节点 的左右两个子树的高度差的绝对值不超过1。那么，我们可以自底向上，即采用后序遍历的方式，只要左右高度超过1了，直接设置 `flase`即可。

```js
 /**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
    if(!root) return true;
    let res = true;
    let dfs = (root) => {
        // 先遍历左子树，在遍历右子树
        let left = root.left && dfs(root.left) + 1;
        let right = root.right && dfs(root.right) + 1;
        // 判断是否是平衡二叉树，就看高度差是否大于1
        if (Math.abs(left - right) > 1) res = false;
        // 返回左右子树深度的最大值
        return Math.max(left, right);
    }
    dfs(root);
    return res;
};
```





## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。

示例 1：

```
输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

示例 2：

```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```

### 思路：

后序遍历，先遍历左孩子，对于孩子的累计和，我们判断一下，如果小于0（即为负数）就没必要加了，直接返回 0 即可，否则加上孩子累计和。然后我们对每一层求一下最大值即可。

```js
var maxPathSum = function (root) {
    let max = Number.MIN_SAFE_INTEGER
    let dfs = (root) => {
        let left = root.left && dfs(root.left)
        let right = root.right && dfs(root.right)
        max = Math.max(max, left + right + root.val)//每判断一个新节点都看下左孩子和+根节点+右孩子之和是否大于最大值
        let sum = Math.max(left, right) + root.val//返回只返回最大的孩子和加根节点
        return sum > 0 ? sum : 0//假如小于0就返回0即可
    }
    dfs(root)
    return max
};
```





## [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
![image-20220410153805710](D:\前端\力扣leecode\二叉树.assets\image-20220410153805710.png)               ![image-20220410153819270](D:\前端\力扣leecode\二叉树.assets\image-20220410153819270.png)
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```



### 解法：

```js
var isSubStructure = function (A, B) {
    let recur = (A, B) => {//判断当前节点的val是否相等
        if (!B) return true;//假如B为null,说明已经判断完毕，可以返回true
        if (!A || A.val !== B.val) return false;//假如不相等或者A都已经判定完了B还没判断完，返回false
        return recur(A.left, B.left) && recur(A.right, B.right);//当前的相等，看他们的字节点是否相等
    }
    //两个节点不能为空
    //判断A自身是否相等，不相等就递归判断左孩子，再递归判断右孩子
    return (A!==null && B!==null) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
};
```





## [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

<img src="D:\前端\力扣leecode\二叉树.assets\image-20220410160729613.png" alt="image-20220410160729613"  />

### 解法：

从叶子节点先开始翻转得到镜像。如果当前遍历到的节点root的左右两棵子树都已经翻转得到镜像，那么我们只需要交换两棵子树的位置，即可得到以root 为根节点的整棵子树的镜像。

```js
var mirrorTree = function (root) {
    if(!root) return null;
    let left = mirrorTree(root.left);//让子树的左右交换，
    let right = mirrorTree(root.right);
    root.left = right;
    root.right =left;
    return root;
};
```



## [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

<img src="D:\前端\力扣leecode\二叉树.assets\bstdlloriginalbst.png" alt="img" style="zoom:33%;" />

<img src="D:\前端\力扣leecode\二叉树.assets\bstdllreturndll.png" alt="img" style="zoom:50%;" />

### 解法：

​	利用中序遍历

```js
var treeToDoublyList = function (root) {
    if (!root) return null;
    let head;
    let pre = null;

    let dfs = (root) => {
        if (!root) return;
        dfs(root.left);
        if (pre !== null) pre.right = root;//假如pre不为空，则令pre.right指向当前
        else head = root;//为空说明到了左叶子节点，为head
        root.left = pre;//当前的left指向pre
        pre = root;//中序遍历，更新pre
        dfs(root.right)
    }
    dfs(root);
    head.left = pre;
    pre.right = head;//退出时，pre指向右孩子节点
    return head
};
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

 **示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

### 解法：

中序遍历，计数

```js
var kthLargest = function (root, k) {//k大==n-k+1小
    let idx = 0;
    let v = 0;
    let dfs = (root) => {
        if (!root) return;
        dfs(root.right);
        if(idx === k)  return;//提前返回
        idx++;
        if (idx === k) {
            v =root.val
            return;
        }
        dfs(root.left);
    }
    dfs(root);
    return v;
};
```



## [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

示例 1:

<img src="D:\前端\力扣leecode\二叉树.assets\tree.jpg" alt="img" style="zoom: 50%;" />

```
Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
```

### 解法：

 // 前序第一个元素  将中序分成左树 与右树
// 取出前序第一个元素做当前树根节点
// 绑定分治左树右树
// 返回当前节点节点

```js
var buildTree = function(preorder, inorder) {
    if(preorder.length <= 0) return null
    let val = preorder.shift();
    let node = new TreeNode(val);
    let index = inorder.indexOf(val);
    let left = inorder.slice(0,index);
    let right = inorder.slice(index+1);
    node.left = buildTree(preorder.slice(0,index),left);//前序数组也index前的都在左子树中
    node.right = buildTree(preorder.slice(index),right);
    return node;
};
```





## [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

         5
        / \
       2   6
      / \
     1   3

示例 1：

```
输入: [1,6,3,2,5]
输出: false
```

示例 2：

```
输入: [1,3,2,6,5]
输出: true
```

### 解法：

最后位置是根节点，然后从头遍历，遇到的第一个大于根节点的值下标为idx。则[0,idx-1]的是左子树，剩余的是右子树。

左子树不用检查，右子树再依次遍历查看是否都大于根节点的值，如果不大于则返回false，如果都大于则递归检查左右子树是否满足后序遍历。

```js
var verifyPostorder = function (postorder) {
    if (postorder.length <= 1) return true;
    let end = postorder.pop();
    let idx = postorder.length;//idx先设置为最后
    for (let i in postorder) {//记录第一个大于end的位置
        if (postorder[i] > end) {
            idx = i;
            break;
        }
    }
    let left = postorder.slice(0, idx);//划分左子树
    let right = postorder.slice(idx);//划分右子树
    for (let i = 0; i < right.length; i++) {//检查右子树的值是否都大于end，左子树不用检查了
        if (right[i] < end) {
            return false;
        }
    }
    return verifyPostorder(left) && verifyPostorder(right);
};
>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
```