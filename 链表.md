<<<<<<< HEAD
<<<<<<< HEAD
## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/addtwonumber1.jpg" alt="img" style="zoom:67%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    let res = new ListNode()
    let p = res
    let sum = 0
    let r = 0
    while (l1 !== null || l2 !== null || r !== 0) {//假如当前还带有进位，继续运算
        let l = new ListNode()
        p.next = l
        p = l
        let n1 = l1 ? l1.val : 0//有可能l1已经到底了，为null则第一个数可看作0
        let n2 = l2 ? l2.val : 0
        sum = n1 + n2 + r
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
        l.val = sum % 10//当前值为mod
        r = Math.floor(sum / 10)//进位为除数向下取整
    }
    return res.next
};
```



## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/removelinked-list.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```js
var removeElements = function (head, val) {
    let p = new ListNode(0)
    p.next = head
    let cur = p
    while (cur.next !== null) {
        if (cur.next.val === val) {
            cur.next = cur.next.next
        } else {
            cur = cur.next
        }

    }
    return p.next
};
```



## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

 **示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/swap_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

### 解法一：交换链表节点的值

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let cur = head
    while(cur!==null){
        if(cur.next===null) break
        let temp = cur.val
        cur.val = cur.next.val
        cur.next.val = temp
        cur = cur.next.next
    }
    return head
};
```

### 解法二：交换节点

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    let p = new ListNode(-1, head)
    let cur = p
    while (cur.next !== null  && cur.next.next !==null) {
        let next = cur.next.next.next
        let node2 = cur.next.next
        let node1 = cur.next
        node2.next = node1
        node1.next = next
        cur.next = node2
        cur = node1
    }
    return p.next
};
```

### 更好的做法，递归：

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    if (!head || !head.next) return head  //若当前为空或者后面没有值，直接返回head节点，奇数个节点
    let n1 = head
    let n2 = n1.next
    let n3 = n2.next
    n2.next = n1
    n1.next = swapPairs(n3)//递归调用，传入第3个节点
    return n2 //因为被交换了，所以返回n2即可
};
```



## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/remove_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

### 自己做法：遍历一遍开辟空间进行存储节点，再进行删除操作

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let p = new ListNode(-1, head)
    let cur = p
    let nodes = []
    while (cur !== null) {
        nodes.push(cur)
        cur = cur.next;
    }
    node = nodes[nodes.length - n - 1]
    node.next = node.next.next
    return p.next
};
```

### 双指针：

<img src="%E9%93%BE%E8%A1%A8.assets/image-20211130221353610.png" alt="image-20211130221353610" style="zoom:67%;" />

```js
var removeNthFromEnd = function (head, n) {
    let dummyNode = new ListNode(-1, head)
    let pre = dummyNode
    let cur = head
    let cnt = 0
    while (cur !== null) {
        if (cnt >= n) {//>=n是因为停止条件时,cur指向的是null而非最后一个节点
            pre = pre.next//若间距达标，跟随cur一起往后移动，直到cur为null
        }
        cnt++
        cur = cur.next
    }
    pre.next = pre.next.next
    return dummyNode.next
};
```



## [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

### 解法：

```js
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function (head, val) {
    let dummyNode = new ListNode(-1, head)//定义哑节点，直接判断后一个
    let cur = dummyNode
    while (cur.next.val !== val) {
        cur = cur.next
    }
    cur.next = cur.next.next
    return dummyNode.next
};
```



## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev1ex1.jpg" alt="img" style="zoom:67%;" />

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

### 迭代：

```js
var reverseList = function (head) {
    let pre = null//记录前一节点信息
    let cur = head
    while (cur) {
        let next = cur.next//保存下一节点信息
        cur.next = pre//当前节点的next=前一节点
        pre = cur//更新前一节点
        cur = next//之前保存的next为新的cur
    }
    return pre
};
```

### 递归：

```js
var reverseList = function(head) {
    if (head == null || head.next == null) {
        return head;
    }
    const newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
};
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev2ex2.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

### 做法一：截取要反转的链表段，反转完再接回去

```js
var reverseBetween = function(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;
    return dummyNode.next;
};

const reverseLinkedList = (head) => {
    let pre = null;
    let cur = head;

    while (cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

### 做法二：头插法（穿针引线）

使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：

curr：指向待反转区域的第一个节点 left；
next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；
pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。

<img src="%E9%93%BE%E8%A1%A8.assets/1615105296-bmiPxl-image.png" alt="img" style="zoom: 33%;" />

操作步骤：

先将 curr 的下一个节点记录为 next；
执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；
执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；
执行操作 ③：把 pre 的下一个节点指向 next。

```js
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```



## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/circularlinkedlist.png" alt="img" style="zoom:67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 做法一：hash表

```js
var detectCycle = function (head) {
    let hash = new Set()//定义集合
    while (head) {
        if (hash.has(head)) return head//调用hash方法
        hash.add(head);
        head = head.next;
    }
    return null
};
```

### 做法三：快慢指针

我们使用两个指针，fast 与slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇

<img src="%E9%93%BE%E8%A1%A8.assets/142_fig1.png" alt="img" style="zoom: 25%;" />

```js
var detectCycle = function(head) {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
};
```



## [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

<img src="D:\前端\力扣leecode\链表.assets\linkedlist1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

做法：

```js
var deleteDuplicates = function (head) {
    let dummyNode = new ListNode(-1, head);
    let cur = dummyNode;
    while (cur.next && cur.next.next) {//后两个不为空才能判断
        if (cur.next.val === cur.next.next.val) {//假如相邻的值相同
            let val = cur.next.val;//保存该值
            while (cur.next && cur.next.val === val) cur.next = cur.next.next;//直到cur.next的值不是重复值
        }
        else{
            cur = cur.next;
        }
    }
    return dummyNode.next;
};
```

=======
## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/addtwonumber1.jpg" alt="img" style="zoom:67%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    let res = new ListNode()
    let p = res
    let sum = 0
    let r = 0
    while (l1 !== null || l2 !== null || r !== 0) {//假如当前还带有进位，继续运算
        let l = new ListNode()
        p.next = l
        p = l
        let n1 = l1 ? l1.val : 0//有可能l1已经到底了，为null则第一个数可看作0
        let n2 = l2 ? l2.val : 0
        sum = n1 + n2 + r
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
        l.val = sum % 10//当前值为mod
        r = Math.floor(sum / 10)//进位为除数向下取整
    }
    return res.next
};
```



## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/removelinked-list.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```js
var removeElements = function (head, val) {
    let p = new ListNode(0)
    p.next = head
    let cur = p
    while (cur.next !== null) {
        if (cur.next.val === val) {
            cur.next = cur.next.next
        } else {
            cur = cur.next
        }

    }
    return p.next
};
```



## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

 **示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/swap_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

### 解法一：交换链表节点的值

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let cur = head
    while(cur!==null){
        if(cur.next===null) break
        let temp = cur.val
        cur.val = cur.next.val
        cur.next.val = temp
        cur = cur.next.next
    }
    return head
};
```

### 解法二：交换节点

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    let p = new ListNode(-1, head)
    let cur = p
    while (cur.next !== null  && cur.next.next !==null) {
        let next = cur.next.next.next
        let node2 = cur.next.next
        let node1 = cur.next
        node2.next = node1
        node1.next = next
        cur.next = node2
        cur = node1
    }
    return p.next
};
```

### 更好的做法，递归：

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    if (!head || !head.next) return head  //若当前为空或者后面没有值，直接返回head节点，奇数个节点
    let n1 = head
    let n2 = n1.next
    let n3 = n2.next
    n2.next = n1
    n1.next = swapPairs(n3)//递归调用，传入第3个节点
    return n2 //因为被交换了，所以返回n2即可
};
```



## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/remove_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

### 自己做法：遍历一遍开辟空间进行存储节点，再进行删除操作

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let p = new ListNode(-1, head)
    let cur = p
    let nodes = []
    while (cur !== null) {
        nodes.push(cur)
        cur = cur.next;
    }
    node = nodes[nodes.length - n - 1]
    node.next = node.next.next
    return p.next
};
```

### 双指针：

<img src="%E9%93%BE%E8%A1%A8.assets/image-20211130221353610.png" alt="image-20211130221353610" style="zoom:67%;" />

```js
var removeNthFromEnd = function (head, n) {
    let dummyNode = new ListNode(-1, head)
    let pre = dummyNode
    let cur = head
    let cnt = 0
    while (cur !== null) {
        if (cnt >= n) {//>=n是因为停止条件时,cur指向的是null而非最后一个节点
            pre = pre.next//若间距达标，跟随cur一起往后移动，直到cur为null
        }
        cnt++
        cur = cur.next
    }
    pre.next = pre.next.next
    return dummyNode.next
};
```



## [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

### 解法：

```js
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function (head, val) {
    let dummyNode = new ListNode(-1, head)//定义哑节点，直接判断后一个
    let cur = dummyNode
    while (cur.next.val !== val) {
        cur = cur.next
    }
    cur.next = cur.next.next
    return dummyNode.next
};
```



## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev1ex1.jpg" alt="img" style="zoom:67%;" />

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

### 迭代：

```js
var reverseList = function (head) {
    let pre = null//记录前一节点信息
    let cur = head
    while (cur) {
        let next = cur.next//保存下一节点信息
        cur.next = pre//当前节点的next=前一节点
        pre = cur//更新前一节点
        cur = next//之前保存的next为新的cur
    }
    return pre
};
```

### 递归：

```js
var reverseList = function(head) {
    if (head == null || head.next == null) {
        return head;
    }
    const newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
};
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev2ex2.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

### 做法一：截取要反转的链表段，反转完再接回去

```js
var reverseBetween = function(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;
    return dummyNode.next;
};

const reverseLinkedList = (head) => {
    let pre = null;
    let cur = head;

    while (cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

### 做法二：头插法（穿针引线）

使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：

curr：指向待反转区域的第一个节点 left；
next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；
pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。

<img src="%E9%93%BE%E8%A1%A8.assets/1615105296-bmiPxl-image.png" alt="img" style="zoom: 33%;" />

操作步骤：

先将 curr 的下一个节点记录为 next；
执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；
执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；
执行操作 ③：把 pre 的下一个节点指向 next。

```js
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```



## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/circularlinkedlist.png" alt="img" style="zoom:67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 做法一：hash表

```js
var detectCycle = function (head) {
    let hash = new Set()//定义集合
    while (head) {
        if (hash.has(head)) return head//调用hash方法
        hash.add(head);
        head = head.next;
    }
    return null
};
```

### 做法三：快慢指针

我们使用两个指针，fast 与slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇

<img src="%E9%93%BE%E8%A1%A8.assets/142_fig1.png" alt="img" style="zoom: 25%;" />

```js
var detectCycle = function(head) {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
};
```



## [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

<img src="D:\前端\力扣leecode\链表.assets\linkedlist1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

做法：

```js
var deleteDuplicates = function (head) {
    let dummyNode = new ListNode(-1, head);
    let cur = dummyNode;
    while (cur.next && cur.next.next) {//后两个不为空才能判断
        if (cur.next.val === cur.next.next.val) {//假如相邻的值相同
            let val = cur.next.val;//保存该值
            while (cur.next && cur.next.val === val) cur.next = cur.next.next;//直到cur.next的值不是重复值
        }
        else{
            cur = cur.next;
        }
    }
    return dummyNode.next;
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/addtwonumber1.jpg" alt="img" style="zoom:67%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

```js
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
    let res = new ListNode()
    let p = res
    let sum = 0
    let r = 0
    while (l1 !== null || l2 !== null || r !== 0) {//假如当前还带有进位，继续运算
        let l = new ListNode()
        p.next = l
        p = l
        let n1 = l1 ? l1.val : 0//有可能l1已经到底了，为null则第一个数可看作0
        let n2 = l2 ? l2.val : 0
        sum = n1 + n2 + r
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
        l.val = sum % 10//当前值为mod
        r = Math.floor(sum / 10)//进位为除数向下取整
    }
    return res.next
};
```



## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/removelinked-list.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

```js
var removeElements = function (head, val) {
    let p = new ListNode(0)
    p.next = head
    let cur = p
    while (cur.next !== null) {
        if (cur.next.val === val) {
            cur.next = cur.next.next
        } else {
            cur = cur.next
        }

    }
    return p.next
};
```



## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

 **示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/swap_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

### 解法一：交换链表节点的值

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let cur = head
    while(cur!==null){
        if(cur.next===null) break
        let temp = cur.val
        cur.val = cur.next.val
        cur.next.val = temp
        cur = cur.next.next
    }
    return head
};
```

### 解法二：交换节点

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    let p = new ListNode(-1, head)
    let cur = p
    while (cur.next !== null  && cur.next.next !==null) {
        let next = cur.next.next.next
        let node2 = cur.next.next
        let node1 = cur.next
        node2.next = node1
        node1.next = next
        cur.next = node2
        cur = node1
    }
    return p.next
};
```

### 更好的做法，递归：

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    if (!head || !head.next) return head  //若当前为空或者后面没有值，直接返回head节点，奇数个节点
    let n1 = head
    let n2 = n1.next
    let n3 = n2.next
    n2.next = n1
    n1.next = swapPairs(n3)//递归调用，传入第3个节点
    return n2 //因为被交换了，所以返回n2即可
};
```



## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/remove_ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

### 自己做法：遍历一遍开辟空间进行存储节点，再进行删除操作

```js
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function (head, n) {
    let p = new ListNode(-1, head)
    let cur = p
    let nodes = []
    while (cur !== null) {
        nodes.push(cur)
        cur = cur.next;
    }
    node = nodes[nodes.length - n - 1]
    node.next = node.next.next
    return p.next
};
```

### 双指针：

<img src="%E9%93%BE%E8%A1%A8.assets/image-20211130221353610.png" alt="image-20211130221353610" style="zoom:67%;" />

```js
var removeNthFromEnd = function (head, n) {
    let dummyNode = new ListNode(-1, head)
    let pre = dummyNode
    let cur = head
    let cnt = 0
    while (cur !== null) {
        if (cnt >= n) {//>=n是因为停止条件时,cur指向的是null而非最后一个节点
            pre = pre.next//若间距达标，跟随cur一起往后移动，直到cur为null
        }
        cnt++
        cur = cur.next
    }
    pre.next = pre.next.next
    return dummyNode.next
};
```



## [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

### 解法：

```js
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var deleteNode = function (head, val) {
    let dummyNode = new ListNode(-1, head)//定义哑节点，直接判断后一个
    let cur = dummyNode
    while (cur.next.val !== val) {
        cur = cur.next
    }
    cur.next = cur.next.next
    return dummyNode.next
};
```



## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev1ex1.jpg" alt="img" style="zoom:67%;" />

输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

### 迭代：

```js
var reverseList = function (head) {
    let pre = null//记录前一节点信息
    let cur = head
    while (cur) {
        let next = cur.next//保存下一节点信息
        cur.next = pre//当前节点的next=前一节点
        pre = cur//更新前一节点
        cur = next//之前保存的next为新的cur
    }
    return pre
};
```

### 递归：

```js
var reverseList = function(head) {
    if (head == null || head.next == null) {
        return head;
    }
    const newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
};
```



## [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

示例 1：

<img src="%E9%93%BE%E8%A1%A8.assets/rev2ex2.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

### 做法一：截取要反转的链表段，反转完再接回去

```js
var reverseBetween = function(head, left, right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    const dummyNode = new ListNode(-1);
    dummyNode.next = head;

    let pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (let i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    let rightNode = pre;
    for (let i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    let leftNode = pre.next;
    let curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;
    return dummyNode.next;
};

const reverseLinkedList = (head) => {
    let pre = null;
    let cur = head;

    while (cur) {
        const next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

### 做法二：头插法（穿针引线）

使用三个指针变量 pre、curr、next 来记录反转的过程中需要的变量，它们的意义如下：

curr：指向待反转区域的第一个节点 left；
next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；
pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。

<img src="%E9%93%BE%E8%A1%A8.assets/1615105296-bmiPxl-image.png" alt="img" style="zoom: 33%;" />

操作步骤：

先将 curr 的下一个节点记录为 next；
执行操作 ①：把 curr 的下一个节点指向 next 的下一个节点；
执行操作 ②：把 next 的下一个节点指向 pre 的下一个节点；
执行操作 ③：把 pre 的下一个节点指向 next。

```js
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```



## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

**示例 1：**

<img src="%E9%93%BE%E8%A1%A8.assets/circularlinkedlist.png" alt="img" style="zoom:67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 做法一：hash表

```js
var detectCycle = function (head) {
    let hash = new Set()//定义集合
    while (head) {
        if (hash.has(head)) return head//调用hash方法
        hash.add(head);
        head = head.next;
    }
    return null
};
```

### 做法三：快慢指针

我们使用两个指针，fast 与slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇

<img src="%E9%93%BE%E8%A1%A8.assets/142_fig1.png" alt="img" style="zoom: 25%;" />

```js
var detectCycle = function(head) {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
};
```



## [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

<img src="D:\前端\力扣leecode\链表.assets\linkedlist1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

做法：

```js
var deleteDuplicates = function (head) {
    let dummyNode = new ListNode(-1, head);
    let cur = dummyNode;
    while (cur.next && cur.next.next) {//后两个不为空才能判断
        if (cur.next.val === cur.next.next.val) {//假如相邻的值相同
            let val = cur.next.val;//保存该值
            while (cur.next && cur.next.val === val) cur.next = cur.next.next;//直到cur.next的值不是重复值
        }
        else{
            cur = cur.next;
        }
    }
    return dummyNode.next;
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
