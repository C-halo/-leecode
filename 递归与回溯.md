<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

示例 1：

```
输出：low = 100, high = 300
输出：[123,234]
```


示例 2：

```
输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]
```

### 做法：

```js
var sequentialDigits = function (low, high) {
    let res = []
    for (i = 2; i <= 9; i++) {//题目给到数字的长度范围
        for (j = 1; j <= 10 - i; j++) {//顺序位的首位，比如两位数的话，首位只能在[1,8]取
            let shun = 0
            for (p = 0; p < i; p++) {
                shun = shun * 10 + j + p//每增加一位p，p都自加1，直到位数达到i，即进行够了i此循环
            }
            if (shun >= low) {
                if (shun <= high) {
                    res.push(shun);
                }
                else {
                    return res;
                }
            }
        }
    }
    return res
};
```



## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiraln.jpg" alt="img" style="zoom:67%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

### 自己做法：

```js
var generateMatrix = function (n) {
    let matrix = new Array(n).fill(1).map(() => new Array(n).fill(1))//生成二维数组
    let num = 1
    let top = 0, right = n, bottom = n, left = 0//生成对应边界
    let i = 0, j = 0
    if (n === 1) return matrix
    while (num <= n * n) {
        while (j < right && num <= n * n) {//填满上面一行
            matrix[i][j] = num
            j++
            num++
        }
        j--//对应的列要--，上面最后多加了
        top++//top界面往下移动
        i++//对应的行要往下移动一行
        while (i < bottom && num <= n * n) {
            matrix[i][j] = num
            i++
            num++
        }
        i--//对应的行要--，上面多加了
        right--//右边界往左移
        j--//列往左移
        while (j >= left && num <= n * n) {
            matrix[i][j] = num
            j--
            num++
        }
        j++//j最后多减了，加回来
        bottom--//下边界往上移
        i--//下一个需要填的行坐标
        while (i >= top && num <= n * n) {
            matrix[i][j] = num
            i--
            num++
        }
        i++//行多-了，+回来
        left++//右边界往右移动
        j++//下一元素的列坐标
    }
    return matrix
};
```

### 更简单做法：

```js
var generateMatrix = function (n) {
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0))
    let up = 0, down = n - 1, left = 0, right = n - 1, index = 1
    while (index <= n * n) {
        for (i = left; i <= right; i++) {
            res[up][i] = index++;
        }
        up++;
        for (i = up; i <= down; i++) {
            res[i][right] = index++;
        }
        right--;
        for (i = right; i >= left; i--) {
            res[down][i] = index++;
        }
        down--;
        for (i = down; i >= up; i--) {
            res[i][left] = index++;
        }
        left++;
    }
    return res;
};
```



## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiral1.jpg" alt="img" style="zoom:67%;" />

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

### 做法：

```js
var spiralOrder = function (matrix) {
    let res = []
    let m = matrix.length
    let n = matrix[0].length
    let left = 0, top = 0, right = n - 1, bottom = m - 1
    let num = m * n
    while (num >= 1) {
        for (i = left; i <= right && num >= 1; i++) {//必须判断是否遍历完所有的数字
            res.push(matrix[top][i])
            num--
        }
        top++
        for (i = top; i <= bottom && num >= 1; i++) {
            res.push(matrix[i][right])
            num--
        }
        right--
        for (i = right; i >= left && num >= 1; i--) {
            res.push(matrix[bottom][i])
            num--
        }
        console.log(res)
        bottom--
        for (i = bottom; i >= top && num >= 1; i--) {
            res.push(matrix[i][left])
            num--
        }
        left++
    }
    return res
};
```



## [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

示例 1：

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：

1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

类似于一笔画问题

### 做法：

```js
var uniquePathsIII = function (grid) {
    let sx, sy
    let cnt = 1
    for (i = 0; i < grid.length; i++) {
        for (j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {//设置起始位置
                sx = i
                sy = j
            }
            if (grid[i][j] === 0) cnt++//统计可走的空格数
        }
    }
    return dfs(sx, sy, grid, cnt)
};
let check = (sx, sy, grid) => {//检查新的起始位置是否合法
    if (sx < 0 || sx >= grid.length || sy < 0 || sy >= grid[0].length || grid[sx][sy] === -1) return false
    //判断起点位置是否超过下标范围，以及起始位置是否为障碍
    return true
}
let dfs = (sx, sy, grid, cnt) => {
    if (!check(sx, sy, grid)) return 0//首先检查下，假如不合格直接return 0
    if (grid[sx][sy] === 2) {//假如当前是终点，需要判断所有的空格是否走完
        return cnt > 0 ? 0 : 1//若cnt正好等于0，路径数+1
    }
    grid[sx][sy] = -1//将该路径设置为不可通行
    let res = 0//统计路径数
    res += dfs(sx - 1, sy, grid, cnt - 1)
    res += dfs(sx, sy - 1, grid, cnt - 1)
    res += dfs(sx + 1, sy, grid, cnt - 1)
    res += dfs(sx, sy + 1, grid, cnt - 1)
    grid[sx][sy] = 0//回溯过程，不影响后续dfs
    return res
}
```

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/inorder_1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    let res = []
    let dfs = (root) => {
        if (!root) return
        dfs(root.left)
        res.push(root.val)
        dfs(root.right)
    }
    dfs(root)
    return res
};
```

## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```js
示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]
```

### 自己做法：

```js
var letterCasePermutation = function (s) {
    let res = [];
    let arrays = s.split('');//转为数组 字符串不能用s[0]='A'更改某个位置的值
    let dfs = (i, array) => {
        if (i === array.length) {
            return res.push(array.join(''));
        }
        if (!isNaN(Number(array[i]))) dfs(i + 1, array.slice());//不是数字直接i+1
        else {
            if ('A' <= array[i] && array[i] <= 'Z') {
                array[i] = array[i].toLowerCase();//大写，则先转小写
            }
            dfs(i + 1, array.slice());//先将小写的递归
            array[i] = array[i].toUpperCase();//此时必是小写，转大写
            dfs(i + 1, array.slice());//递归
        }
    }
    dfs(0, arrays);
    return res;
};
```

### 做法：

```js
var letterCasePermutation = function (s) {
    let n = s.length
    let res = []
    let dfs = (t, str) => {
        if (t.length === n)
            return res.push(t)//若遍历完成，返回将结果存入res并return
        let ch = str[0]//得到当前第一个字符
        let nextstr = str.substr(1)//截取下一步dfs的str
        if (!isNaN(Number(ch))) {
            dfs(t + ch, nextstr)//若为数字直接t+ch，
        } else {
            let tmp = ch.toUpperCase()//将字符转为大写
            if (tmp === ch) ch = ch.toLowerCase()//若本身就是大写，转为小写
            dfs(t + ch, nextstr)
            dfs(t + tmp, nextstr)
        }
    }
    dfs('', s)
    return res
};
```



## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

```
示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```

### 做法：

```js
var getMaximumGold = function (grid) {
    let m = grid.length
    let n = grid[0].length
    let max = Number.MIN_VALUE
    for (i = 0; i < m; i++) {//每个点挨着遍历
        for (j = 0; j < n; j++) {
            max = max > dfs(i, j, grid) ? max : dfs(i, j, grid)
        }
    }
    return max
};
let check = (i, j, grid) => {//检查合格性
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0)
        return false
    return true
}
let dfs = (i, j, grid) => {
    if (!check(i, j, grid)) return 0
    let res1 = 0
    let res2 = 0
    let res3 = 0
    let res4 = 0
    let val = grid[i][j]
    let res = grid[i][j]
    grid[i][j] = 0
    res1 += dfs(i + 1, j, grid)//记录四个方向的值
    res2 += dfs(i - 1, j, grid)
    res3 += dfs(i, j + 1, grid)
    res4 += dfs(i,  j - 1, grid)
    grid[i][j] = val
    return res + Math.max(res1, res2, res3, res4)//自己的值加四个方向最大的结果作为返回值
}
```



## [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

### 自己做法（不对）：

```js
var permutation = function (S) {
    let res = []
    let n = S.length
    let pos = []
    for (i = 0; i < n; i++) {
        pos.push(i)
    }
    let dfs = (str, loc, i) => {
        let temp = [...pos]
        str += S[loc]//添加该字符
        pos.splice(i, 1)//该位置将不再参与计算
        if (pos.length === 0) {
            if (res.includes(str)) return ''
            return res.push(str)
        }
        for (let i in pos) {
            dfs(str, pos[i], i)
        }
        pos = temp
        return str//还原
    }
    for (let i in pos) {
        dfs('', pos[i], i)
    }
    return res
};
```

### 做法：（全排列直接回溯法）

```js
var permutation = function (S) {
  let res = new Set()
  let vis = []
  let dfs = (t) => {
    if (t.length === S.length) return res.add(t)
    for (let i = 0; i < S.length; i++) {
      if (vis[i]) continue
      vis[i] = true
      dfs(t + S[i])
      vis[i] = false
    }
  }
  dfs('')
  return [...res]
}
```



## [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/search1.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

### 自己做法：（部分测试用例超时）

```js
var findWords = function (board, words) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(board, i, j, '', words, res)
        }
    }
    return res
};
let check = (board, i, j) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === 'error') return false
    return true
}
let dfs = (board, i, j, word, words, res) => {
    if (words.length === res.length) return
    if (!check(board, i, j)) return
    let char = board[i][j]
    board[i][j] = 'error'
    word += char
    if (words.includes(word) && res.indexOf(word) < 0) {
        res.push(word)
    }
    dfs(board, i, j + 1, word, words, res)
    dfs(board, i, j - 1, word, words, res)
    dfs(board, i + 1, j, word, words, res)
    dfs(board, i - 1, j, word, words, res)

    board[i][j] = char
}
```

### 字典树+回溯：

- 判断是否找到了，通过传递节点的END来判断
- 判断是否重复访问，通过动态更改走过的网格点来判断，就不需要再定义一个`vis`数组了

```js
var findWords = function(grid, words) {
  // 存放最终结果集
  let res = []
  // 字典树节点
  class TrieNode {
    constructor(){
      this.end = false
      this.child = {}
    }
  }
  // 最终形成的字典树根节点
  let root = null
  let Trie = function(){
    root = new TrieNode()
  }
  // 建立字典树
  Trie.prototype.insert = (word) => {
    let cur = root
    for(let i=0;i<word.length;i++){
      if(!cur.child[word[i]]){
        cur.child[word[i]] = new TrieNode()
      }
      cur = cur.child[word[i]]
    }
    cur.end = true
  }
  // 创建根节点
  let trie = new Trie()
  // 进行建树操作
  for(let i=0;i<words.length;i++){
    trie.insert(words[i])
  }
  let dfs = (x,y,t,cur) => {
    if(cur.end){
      res.push(t)
      cur.end = false // 避免重复计算
    }
    // 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走
    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == '#' || !cur.child[grid[x][y]]) return
    let tmp = grid[x][y]
    grid[x][y] = '#'  // 走
    cur = cur.child[tmp]
    dfs(x+1,y,t+tmp,cur)  // 上下左右四个方向遍历
    dfs(x,y+1,t+tmp,cur)
    dfs(x-1,y,t+tmp,cur)
    dfs(x,y-1,t+tmp,cur)
    grid[x][y] = tmp // 回溯（还原）
  }
  // 对单词表进行全局搜索
  for(let i=0;i<grid.length;i++){
    for(let j=0;j<grid[0].length;j++){
      dfs(i,j,'',root)
    }
  }
  return res
};
```



## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/word2.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

### 自己做法：

```js
var exist = function (board, word) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(i, j, board, '', word, res)
            if (res.includes(word)) return true
        }
    }
    return false
};
let check = (i, j, board) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === '1') return false
    return true
}
let dfs = (i, j, board, str, word, res) => {
    if (!check(i, j, board)) return
    let char = board[i][j]
    if (char !== word[str.length]) return
    str += char
    board[i][j] = '1'
    if (str === word) {
        return res.push(str)
    }
    dfs(i, j + 1, board, str, word, res)
    dfs(i, j - 1, board, str, word, res)
    dfs(i + 1, j, board, str, word, res)
    dfs(i - 1, j, board, str, word, res)
    board[i][j] = char
}
```

### 官方解法:

```js
var exist = function (board, word) {
    let m = board.length;
    let n = board[0].length;
    let vis = new Array(m).fill(0).map(() => new Array(n).fill(0));
    let dfs = (x, y, k) => {
        if (x < 0 || x >= m || y < 0 || y >= n || word[k] !== board[x][y]) {
            return false;
        }
        if (k === word.length - 1) {
            return true;
        }
        board[x][y] = '';
        let res = dfs(x - 1, y, k + 1) || dfs(x + 1, y, k + 1)
            || dfs(x, y + 1, k + 1) || dfs(x, y - 1, k + 1);
        board[x][y] = word[k];
        return res;
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0)) return true;
        }
    }
    return false;
};
```



## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 `"3:25"` 。

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/binary_clock_samui_moon.jpg" alt="img" style="zoom: 20%;" />

### 解题思路

回溯算法，我的解法类似于全排列做法，将10个小灯泡进行排列组合，然后根据 `0` 和 `1` 来判断灯泡是否亮，如果亮了，加上对应二进制，然后将 `0-3`分给小时来计算，将 `4-9`分给分钟来计算，但是要考虑一下，就是可能会出现重复情况，于是用 `Set`数据结构维护一下就好了。

```js
var readBinaryWatch = function (turnedOn) {
    let vis = new Array(10).fill(0)
    let res = []
    let dfs = (index, onnum) => {
        if (onnum == 0) {
            hour = vis[6] * 1 + vis[7] * 2 + vis[8] * 4 + vis[9] * 8
            min = vis[0] * 1 + vis[1] * 2 + vis[2] * 4 + vis[3] * 8 + vis[4] * 16 + vis[5] * 32
            if (check(hour, min)) {
                let t = `${hour}:${min >= 10 ? min : '0' + min}`
                res.push(t)
            }
            return
        }
        for (let i = index; i <= 10 - onnum; i++) {//全排列问题，进行了去重操作，关键点在回溯 for循环。
            if (vis[i]) continue
            vis[i] = 1
            dfs(i + 1, onnum - 1)
            vis[i] = 0
        }
    }
    dfs(0,turnedOn)
    return res
};
let check = (hour, min) => {
    if (hour <= 11 && hour >= 0 && min <= 59 && min >= 0) return true
    return false
}
```



## [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

### 解法：

```js
var subsets = function (nums) {
    let res = []
    let dfs = (arr, start) => {
        res.push(arr)
        if (arr.length === nums.length) return
        for (let i = start; i < nums.length; i++) {
            arr.push(nums[i])
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```

### 解法二：

```js
var subsets = function (nums) {
    const res = [];
    res.push([]);
    for (let num of nums) {
        let temp = [];
        for (let i in res) {
            let t = res[i].slice();
            t.push(num);
            temp.push(t);
        }
        res.push(...temp);
    }
    return res;
};
```



## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### 解法：

<img src="https://camo.githubusercontent.com/789ba6dd32b800b4e042cf42ee2f72e2557e9f15b99c9fcafad3635b8d32d192/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383134323134313537322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var subsetsWithDup = function (nums) {
    let res = [];
    nums.sort((a, b) => a - b);
    let dfs = (t, start) => {
        res.push(t);
        for (let i = start; i < nums.length; i++) {
            // 同层重复，跳过
            if (i > start && nums[i - 1] == nums[i]) continue;
            t.push(nums[i]);
            dfs(t.slice(), i + 1);//t.slice()=[...t] 不带参数，浅拷贝，更改副本可能更改原变量的值
            t.pop();//保证同层循环，入口数组是同一个
        }
    }
    dfs([], 0);
    return res;
};
```



## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 做法：

```js
var permute = function (nums) {
    let res = []
    let vis = []
    let dfs = (arr) => {
        if (arr.length === nums.length) {
            return res.push(arr)
        }
        for (let i = 0; i < nums.length; i++) {
            if (vis[i]) continue
            vis[i] = true
            let temp = [...arr]
            arr.push(nums[i])
            dfs(arr)
            vis[i] = false//标志位复原
            arr = temp//arr数组复原
        }
    }
    dfs([]);
    return res;
};
```



## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

### 解题思路：

<img src="https://camo.githubusercontent.com/c2431469e0869a6fcac989fe483fa1d4de537d0513cbe0b976c25477763fdfd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383135303931323433302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

对于每一层而言，需要判断相邻元素是否相同，相同的就没必要走了。

与同一层的上一个选项 `nums[i - 1]` 相同，且 `nums[i - 1]`有意义（即索引 `>= 0`），且没有被使用过，那就跳过该选项。

因为 `nums[i - 1]`如果被使用过，它会被修剪掉，不是一个选项了，即便它和 `nums[i]`重复，`nums[i]`还是可以选的。

```js
var permuteUnique = function (nums) {
    let res = []
    nums.sort((a, b) => a - b);//排个序先
    let vis = new Array(nums.length).fill(0)
    let dfs = (arr) => {
        if (nums.length === arr.length) res.push(arr)
        for (let i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] === nums[i - 1] && vis[i - 1] === 0) continue//同层之前有重复元素，且没被访问过，说明是重复
            if (vis[i]) continue
            vis[i] = 1
            arr.push(nums[i])
            dfs(arr.slice())
            arr.pop()
            vis[i] = 0
        }
    }
    dfs([])
    return res
};
```



## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

### 做法一：

时间复杂度高，因为并没有剪枝，

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先从小打到排序
    let res = []
    let dfs = (arr, total) => {
        if (total === target) {
            arr.sort((a, b) => a - b)
            for (r of res) {
                if (r.toString() === arr.toString()) {//判断结果中是否有同样的答案
                    return
                }
            }
            return res.push(arr)
        }
        if (total > target) return
        for (let i = 0; i < candidates.length; i++) {
            arr.push(candidates[i])
            let t = total
            total += candidates[i]
            dfs(arr.slice(), total)
            arr.pop()
            total = t
        }
    }
    dfs([], 0)
    return res
};
```

### 更好做法：

<img src="https://camo.githubusercontent.com/c3ffef944bf3879f161e23ec5203d2ef2254277dd78e2d245e31a2380bb0ea5e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383136353734323833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先排序
    let res = []
    let dfs = (arr, start, total) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            arr.push(candidates[i])
            dfs(arr.slice(), i, total + candidates[i])//下一次就只从自己开始，因为前面的必然重复计算过了
            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。 

 示例 1:

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

### 思路：

跟上一题差不多，但是有重复元素。同层遍历不能重复，不同层可以重复。

做法一：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    let vis = new Array(candidates.length).fill(0)
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > 0 && candidates[i] === candidates[i - 1] && vis[i - 1] === 0) continue
            vis[i] = 1
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
            vis[i] = 0
        }
    }
    dfs([], 0, 0)
    return res
};
```

做法二：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] === candidates[i - 1]) continue //只看start后面的即可，不是从0开始
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

### 做法：

```js
var combinationSum3 = function (k, n) {
    let res = []
    let dfs = (arr, start, total) => {
        if (arr.length > k || total > n) return
        if (arr.length === k && total === n) {
            return res.push(arr)
        }
        for (let i = start; i < 10; i++) {
            arr.push(i)

            dfs(arr.slice(), i + 1, total + i)//避免重复直接从当前的下一个开始

            arr.pop()
        }
    }
    dfs([], 1, 0)
    return res
};
```





## [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

示例 1：

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 做法：

```js
var combine = function (n, k) {
    let res = []
    let dfs = (arr, start) => {
        if (arr.length === k) {
            return res.push(arr)
        }
        for (let i = start; i <= n; i++) {
            arr.push(i)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 1)
    return res
};
```



## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

**示例：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714svg.png" alt="img" style="zoom:50%;" />

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714_solutionsvg.png" alt="img" style="zoom:50%;" />

### 做法：

```js
var solveSudoku = function (board) {
    let check = (x, y, val) => {
        //该行列有重复元素
        for (let i = 0; i < 9; i++) {
            if (board[x][i] === val || board[i][y] === val) return true
        }
        let xx = x / 3 * 3
        let yy = y / 3 * 3
        //九宫格内是否重复
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[xx + i][yy + j] === val) return true
            }
        }
        return false
    }

    let dfs = (x, y) => {
        if (y === 9) {
            x++
            y = 0
            if (x === 9) return true
        }
        if (board[x][y] !== '.') return dfs(x, y + 1)
        for (let i = 1; i < 10; i++) {
            if (check(x, y, String(i))) continue  //遍历数字1-9是否重复
            board[x][y] = String(i)//给该位置赋值
            if (dfs(x, y + 1)) return true //能够解出数独 返回true
            board[x][y] = '.'//否则回溯
        }
        return false
    }
    dfs(0, 0)
    return board
};
```



## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/queens.jpg" alt="img" style="zoom:50%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

### 做法：

```js
var solveNQueens = function (n) {
    let grid = new Array(n).fill('.').map(() => new Array(n).fill('.')); // 初始化一个地图
    let res = []
    let check = (x, y) => {//检查该位置是否重复
        for (let i = 0; i < x; i++) {//判断之前已经放入过皇后的行
            for (let j = 0; j < n; j++) {
                // 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）
                // i + j === x + y是左下角      i - j === x - y是右下角
                if (grid[i][j] === 'Q' && (j === y || i + j === x + y || i - j === x - y)) {
                    return true;
                }
            }
        }
        return false;
    }
    let dfs = (t) => {
        if (t === n) {
            let ans = grid.slice(); // 拷贝一份，对输出做处理
            for (let i = 0; i < n; i++) {
                ans[i] = ans[i].join('');//将数组转为string
            }
            res.push(ans)//若皇后的数量等于n，说明是一种解决方案，放置到res中
            return
        }
        for (let i = 0; i < n; i++) {//第一行的每一列依次试一遍
            if (check(t, i)) continue;//重复直接判断下一列
            grid[t][i] = 'Q';
            dfs(t + 1);
            grid[t][i] = '.';
        }
    }
    dfs(0)
    return res
};
```



## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

### 思路：

<img src="https://camo.githubusercontent.com/c80ca562d26b469450d21d9b9056ea8bf146943866010d6aa9e48f2c7cc9f6a0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343134323130323339352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

```js
var partition = function (s) {
    let res = []
    let check = (str) => {//检查是否为回文串
        if (str === '') return true
        for (let i = 0; i < Math.floor(str.length / 2); i++) {
            if (str[i] !== str[str.length - 1 - i]) return false
        }
        return true
    }
    let dfs = (arr, start) => {//字符数组，起始位置
        if (start === s.length) {
            return res.push(arr)
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)//截取字符串
            if (check(str)) {//当前不是回文直接假如下一个字符，进入下一次循环
                arr.push(str)
                dfs(arr.slice(), i + 1)
                arr.pop()
            }
        }
    }
    dfs([], 0)
    return res
};
```





## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

### 解法：

和回文串的思路很相同，截取字符，判断当前字符是否符合标准，回溯

```js
var restoreIpAddresses = function (s) {
    let res = []
    let check = (str) => {//判断字符是否符合IP标准
        if (str.length > 1 && str[0] === '0') return false
        let val = parseInt(str)
        if (val <= 255 && val >= 0) return true
        return false
    }
    let dfs = (arr, start) => {
        if (arr.length === 4) {//数组长度为4进入判断
            if (start === s.length) {//若没有判断最后一个字符
                res.push(arr.join('.'))
            }
            return
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)
            if (!check(str)) continue//如果当前字符不满足ip地址，进入下一次循环
            arr.push(str)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```





## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

### 解法：

有左括号就选左括号，若右括号数量大于左括号，也能选

<img src="https://camo.githubusercontent.com/6d555b8550aa7cce132ecec4c0a1f4c6aae025840c4a6bb4fcfe6d0b3d31df6c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343135343433333533372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var generateParenthesis = function (n) {
    let res = []
    let dfs = (leftnum, rightnum, str) => {//给出剩余左右括号的数量
        if (str.length === n * 2) {
            return res.push(str)
        }
        if (leftnum > 0) dfs(leftnum - 1, rightnum, str + '(')//有左括号就选
        if (rightnum > leftnum) dfs(leftnum, rightnum - 1, str + ')')//若右括号大于左括号数量，也能选
    }
    dfs(n,n,'')
    return res
};
```

=======
## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

示例 1：

```
输出：low = 100, high = 300
输出：[123,234]
```


示例 2：

```
输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]
```

### 做法：

```js
var sequentialDigits = function (low, high) {
    let res = []
    for (i = 2; i <= 9; i++) {//题目给到数字的长度范围
        for (j = 1; j <= 10 - i; j++) {//顺序位的首位，比如两位数的话，首位只能在[1,8]取
            let shun = 0
            for (p = 0; p < i; p++) {
                shun = shun * 10 + j + p//每增加一位p，p都自加1，直到位数达到i，即进行够了i此循环
            }
            if (shun >= low) {
                if (shun <= high) {
                    res.push(shun);
                }
                else {
                    return res;
                }
            }
        }
    }
    return res
};
```



## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiraln.jpg" alt="img" style="zoom:67%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

### 自己做法：

```js
var generateMatrix = function (n) {
    let matrix = new Array(n).fill(1).map(() => new Array(n).fill(1))//生成二维数组
    let num = 1
    let top = 0, right = n, bottom = n, left = 0//生成对应边界
    let i = 0, j = 0
    if (n === 1) return matrix
    while (num <= n * n) {
        while (j < right && num <= n * n) {//填满上面一行
            matrix[i][j] = num
            j++
            num++
        }
        j--//对应的列要--，上面最后多加了
        top++//top界面往下移动
        i++//对应的行要往下移动一行
        while (i < bottom && num <= n * n) {
            matrix[i][j] = num
            i++
            num++
        }
        i--//对应的行要--，上面多加了
        right--//右边界往左移
        j--//列往左移
        while (j >= left && num <= n * n) {
            matrix[i][j] = num
            j--
            num++
        }
        j++//j最后多减了，加回来
        bottom--//下边界往上移
        i--//下一个需要填的行坐标
        while (i >= top && num <= n * n) {
            matrix[i][j] = num
            i--
            num++
        }
        i++//行多-了，+回来
        left++//右边界往右移动
        j++//下一元素的列坐标
    }
    return matrix
};
```

### 更简单做法：

```js
var generateMatrix = function (n) {
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0))
    let up = 0, down = n - 1, left = 0, right = n - 1, index = 1
    while (index <= n * n) {
        for (i = left; i <= right; i++) {
            res[up][i] = index++;
        }
        up++;
        for (i = up; i <= down; i++) {
            res[i][right] = index++;
        }
        right--;
        for (i = right; i >= left; i--) {
            res[down][i] = index++;
        }
        down--;
        for (i = down; i >= up; i--) {
            res[i][left] = index++;
        }
        left++;
    }
    return res;
};
```



## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiral1.jpg" alt="img" style="zoom:67%;" />

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

### 做法：

```js
var spiralOrder = function (matrix) {
    let res = []
    let m = matrix.length
    let n = matrix[0].length
    let left = 0, top = 0, right = n - 1, bottom = m - 1
    let num = m * n
    while (num >= 1) {
        for (i = left; i <= right && num >= 1; i++) {//必须判断是否遍历完所有的数字
            res.push(matrix[top][i])
            num--
        }
        top++
        for (i = top; i <= bottom && num >= 1; i++) {
            res.push(matrix[i][right])
            num--
        }
        right--
        for (i = right; i >= left && num >= 1; i--) {
            res.push(matrix[bottom][i])
            num--
        }
        console.log(res)
        bottom--
        for (i = bottom; i >= top && num >= 1; i--) {
            res.push(matrix[i][left])
            num--
        }
        left++
    }
    return res
};
```



## [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

示例 1：

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：

1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

类似于一笔画问题

### 做法：

```js
var uniquePathsIII = function (grid) {
    let sx, sy
    let cnt = 1
    for (i = 0; i < grid.length; i++) {
        for (j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {//设置起始位置
                sx = i
                sy = j
            }
            if (grid[i][j] === 0) cnt++//统计可走的空格数
        }
    }
    return dfs(sx, sy, grid, cnt)
};
let check = (sx, sy, grid) => {//检查新的起始位置是否合法
    if (sx < 0 || sx >= grid.length || sy < 0 || sy >= grid[0].length || grid[sx][sy] === -1) return false
    //判断起点位置是否超过下标范围，以及起始位置是否为障碍
    return true
}
let dfs = (sx, sy, grid, cnt) => {
    if (!check(sx, sy, grid)) return 0//首先检查下，假如不合格直接return 0
    if (grid[sx][sy] === 2) {//假如当前是终点，需要判断所有的空格是否走完
        return cnt > 0 ? 0 : 1//若cnt正好等于0，路径数+1
    }
    grid[sx][sy] = -1//将该路径设置为不可通行
    let res = 0//统计路径数
    res += dfs(sx - 1, sy, grid, cnt - 1)
    res += dfs(sx, sy - 1, grid, cnt - 1)
    res += dfs(sx + 1, sy, grid, cnt - 1)
    res += dfs(sx, sy + 1, grid, cnt - 1)
    grid[sx][sy] = 0//回溯过程，不影响后续dfs
    return res
}
```

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/inorder_1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    let res = []
    let dfs = (root) => {
        if (!root) return
        dfs(root.left)
        res.push(root.val)
        dfs(root.right)
    }
    dfs(root)
    return res
};
```

## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```js
示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]
```

### 自己做法：

```js
var letterCasePermutation = function (s) {
    let res = [];
    let arrays = s.split('');//转为数组 字符串不能用s[0]='A'更改某个位置的值
    let dfs = (i, array) => {
        if (i === array.length) {
            return res.push(array.join(''));
        }
        if (!isNaN(Number(array[i]))) dfs(i + 1, array.slice());//不是数字直接i+1
        else {
            if ('A' <= array[i] && array[i] <= 'Z') {
                array[i] = array[i].toLowerCase();//大写，则先转小写
            }
            dfs(i + 1, array.slice());//先将小写的递归
            array[i] = array[i].toUpperCase();//此时必是小写，转大写
            dfs(i + 1, array.slice());//递归
        }
    }
    dfs(0, arrays);
    return res;
};
```

### 做法：

```js
var letterCasePermutation = function (s) {
    let n = s.length
    let res = []
    let dfs = (t, str) => {
        if (t.length === n)
            return res.push(t)//若遍历完成，返回将结果存入res并return
        let ch = str[0]//得到当前第一个字符
        let nextstr = str.substr(1)//截取下一步dfs的str
        if (!isNaN(Number(ch))) {
            dfs(t + ch, nextstr)//若为数字直接t+ch，
        } else {
            let tmp = ch.toUpperCase()//将字符转为大写
            if (tmp === ch) ch = ch.toLowerCase()//若本身就是大写，转为小写
            dfs(t + ch, nextstr)
            dfs(t + tmp, nextstr)
        }
    }
    dfs('', s)
    return res
};
```



## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

```
示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```

### 做法：

```js
var getMaximumGold = function (grid) {
    let m = grid.length
    let n = grid[0].length
    let max = Number.MIN_VALUE
    for (i = 0; i < m; i++) {//每个点挨着遍历
        for (j = 0; j < n; j++) {
            max = max > dfs(i, j, grid) ? max : dfs(i, j, grid)
        }
    }
    return max
};
let check = (i, j, grid) => {//检查合格性
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0)
        return false
    return true
}
let dfs = (i, j, grid) => {
    if (!check(i, j, grid)) return 0
    let res1 = 0
    let res2 = 0
    let res3 = 0
    let res4 = 0
    let val = grid[i][j]
    let res = grid[i][j]
    grid[i][j] = 0
    res1 += dfs(i + 1, j, grid)//记录四个方向的值
    res2 += dfs(i - 1, j, grid)
    res3 += dfs(i, j + 1, grid)
    res4 += dfs(i,  j - 1, grid)
    grid[i][j] = val
    return res + Math.max(res1, res2, res3, res4)//自己的值加四个方向最大的结果作为返回值
}
```



## [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

### 自己做法（不对）：

```js
var permutation = function (S) {
    let res = []
    let n = S.length
    let pos = []
    for (i = 0; i < n; i++) {
        pos.push(i)
    }
    let dfs = (str, loc, i) => {
        let temp = [...pos]
        str += S[loc]//添加该字符
        pos.splice(i, 1)//该位置将不再参与计算
        if (pos.length === 0) {
            if (res.includes(str)) return ''
            return res.push(str)
        }
        for (let i in pos) {
            dfs(str, pos[i], i)
        }
        pos = temp
        return str//还原
    }
    for (let i in pos) {
        dfs('', pos[i], i)
    }
    return res
};
```

### 做法：（全排列直接回溯法）

```js
var permutation = function (S) {
  let res = new Set()
  let vis = []
  let dfs = (t) => {
    if (t.length === S.length) return res.add(t)
    for (let i = 0; i < S.length; i++) {
      if (vis[i]) continue
      vis[i] = true
      dfs(t + S[i])
      vis[i] = false
    }
  }
  dfs('')
  return [...res]
}
```



## [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/search1.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

### 自己做法：（部分测试用例超时）

```js
var findWords = function (board, words) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(board, i, j, '', words, res)
        }
    }
    return res
};
let check = (board, i, j) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === 'error') return false
    return true
}
let dfs = (board, i, j, word, words, res) => {
    if (words.length === res.length) return
    if (!check(board, i, j)) return
    let char = board[i][j]
    board[i][j] = 'error'
    word += char
    if (words.includes(word) && res.indexOf(word) < 0) {
        res.push(word)
    }
    dfs(board, i, j + 1, word, words, res)
    dfs(board, i, j - 1, word, words, res)
    dfs(board, i + 1, j, word, words, res)
    dfs(board, i - 1, j, word, words, res)

    board[i][j] = char
}
```

### 字典树+回溯：

- 判断是否找到了，通过传递节点的END来判断
- 判断是否重复访问，通过动态更改走过的网格点来判断，就不需要再定义一个`vis`数组了

```js
var findWords = function(grid, words) {
  // 存放最终结果集
  let res = []
  // 字典树节点
  class TrieNode {
    constructor(){
      this.end = false
      this.child = {}
    }
  }
  // 最终形成的字典树根节点
  let root = null
  let Trie = function(){
    root = new TrieNode()
  }
  // 建立字典树
  Trie.prototype.insert = (word) => {
    let cur = root
    for(let i=0;i<word.length;i++){
      if(!cur.child[word[i]]){
        cur.child[word[i]] = new TrieNode()
      }
      cur = cur.child[word[i]]
    }
    cur.end = true
  }
  // 创建根节点
  let trie = new Trie()
  // 进行建树操作
  for(let i=0;i<words.length;i++){
    trie.insert(words[i])
  }
  let dfs = (x,y,t,cur) => {
    if(cur.end){
      res.push(t)
      cur.end = false // 避免重复计算
    }
    // 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走
    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == '#' || !cur.child[grid[x][y]]) return
    let tmp = grid[x][y]
    grid[x][y] = '#'  // 走
    cur = cur.child[tmp]
    dfs(x+1,y,t+tmp,cur)  // 上下左右四个方向遍历
    dfs(x,y+1,t+tmp,cur)
    dfs(x-1,y,t+tmp,cur)
    dfs(x,y-1,t+tmp,cur)
    grid[x][y] = tmp // 回溯（还原）
  }
  // 对单词表进行全局搜索
  for(let i=0;i<grid.length;i++){
    for(let j=0;j<grid[0].length;j++){
      dfs(i,j,'',root)
    }
  }
  return res
};
```



## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/word2.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

### 自己做法：

```js
var exist = function (board, word) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(i, j, board, '', word, res)
            if (res.includes(word)) return true
        }
    }
    return false
};
let check = (i, j, board) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === '1') return false
    return true
}
let dfs = (i, j, board, str, word, res) => {
    if (!check(i, j, board)) return
    let char = board[i][j]
    if (char !== word[str.length]) return
    str += char
    board[i][j] = '1'
    if (str === word) {
        return res.push(str)
    }
    dfs(i, j + 1, board, str, word, res)
    dfs(i, j - 1, board, str, word, res)
    dfs(i + 1, j, board, str, word, res)
    dfs(i - 1, j, board, str, word, res)
    board[i][j] = char
}
```

### 官方解法:

```js
var exist = function (board, word) {
    let m = board.length;
    let n = board[0].length;
    let vis = new Array(m).fill(0).map(() => new Array(n).fill(0));
    let dfs = (x, y, k) => {
        if (x < 0 || x >= m || y < 0 || y >= n || word[k] !== board[x][y]) {
            return false;
        }
        if (k === word.length - 1) {
            return true;
        }
        board[x][y] = '';
        let res = dfs(x - 1, y, k + 1) || dfs(x + 1, y, k + 1)
            || dfs(x, y + 1, k + 1) || dfs(x, y - 1, k + 1);
        board[x][y] = word[k];
        return res;
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0)) return true;
        }
    }
    return false;
};
```



## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 `"3:25"` 。

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/binary_clock_samui_moon.jpg" alt="img" style="zoom: 20%;" />

### 解题思路

回溯算法，我的解法类似于全排列做法，将10个小灯泡进行排列组合，然后根据 `0` 和 `1` 来判断灯泡是否亮，如果亮了，加上对应二进制，然后将 `0-3`分给小时来计算，将 `4-9`分给分钟来计算，但是要考虑一下，就是可能会出现重复情况，于是用 `Set`数据结构维护一下就好了。

```js
var readBinaryWatch = function (turnedOn) {
    let vis = new Array(10).fill(0)
    let res = []
    let dfs = (index, onnum) => {
        if (onnum == 0) {
            hour = vis[6] * 1 + vis[7] * 2 + vis[8] * 4 + vis[9] * 8
            min = vis[0] * 1 + vis[1] * 2 + vis[2] * 4 + vis[3] * 8 + vis[4] * 16 + vis[5] * 32
            if (check(hour, min)) {
                let t = `${hour}:${min >= 10 ? min : '0' + min}`
                res.push(t)
            }
            return
        }
        for (let i = index; i <= 10 - onnum; i++) {//全排列问题，进行了去重操作，关键点在回溯 for循环。
            if (vis[i]) continue
            vis[i] = 1
            dfs(i + 1, onnum - 1)
            vis[i] = 0
        }
    }
    dfs(0,turnedOn)
    return res
};
let check = (hour, min) => {
    if (hour <= 11 && hour >= 0 && min <= 59 && min >= 0) return true
    return false
}
```



## [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

### 解法：

```js
var subsets = function (nums) {
    let res = []
    let dfs = (arr, start) => {
        res.push(arr)
        if (arr.length === nums.length) return
        for (let i = start; i < nums.length; i++) {
            arr.push(nums[i])
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```

### 解法二：

```js
var subsets = function (nums) {
    const res = [];
    res.push([]);
    for (let num of nums) {
        let temp = [];
        for (let i in res) {
            let t = res[i].slice();
            t.push(num);
            temp.push(t);
        }
        res.push(...temp);
    }
    return res;
};
```



## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### 解法：

<img src="https://camo.githubusercontent.com/789ba6dd32b800b4e042cf42ee2f72e2557e9f15b99c9fcafad3635b8d32d192/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383134323134313537322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var subsetsWithDup = function (nums) {
    let res = [];
    nums.sort((a, b) => a - b);
    let dfs = (t, start) => {
        res.push(t);
        for (let i = start; i < nums.length; i++) {
            // 同层重复，跳过
            if (i > start && nums[i - 1] == nums[i]) continue;
            t.push(nums[i]);
            dfs(t.slice(), i + 1);//t.slice()=[...t] 不带参数，浅拷贝，更改副本可能更改原变量的值
            t.pop();//保证同层循环，入口数组是同一个
        }
    }
    dfs([], 0);
    return res;
};
```



## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 做法：

```js
var permute = function (nums) {
    let res = []
    let vis = []
    let dfs = (arr) => {
        if (arr.length === nums.length) {
            return res.push(arr)
        }
        for (let i = 0; i < nums.length; i++) {
            if (vis[i]) continue
            vis[i] = true
            let temp = [...arr]
            arr.push(nums[i])
            dfs(arr)
            vis[i] = false//标志位复原
            arr = temp//arr数组复原
        }
    }
    dfs([]);
    return res;
};
```



## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

### 解题思路：

<img src="https://camo.githubusercontent.com/c2431469e0869a6fcac989fe483fa1d4de537d0513cbe0b976c25477763fdfd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383135303931323433302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

对于每一层而言，需要判断相邻元素是否相同，相同的就没必要走了。

与同一层的上一个选项 `nums[i - 1]` 相同，且 `nums[i - 1]`有意义（即索引 `>= 0`），且没有被使用过，那就跳过该选项。

因为 `nums[i - 1]`如果被使用过，它会被修剪掉，不是一个选项了，即便它和 `nums[i]`重复，`nums[i]`还是可以选的。

```js
var permuteUnique = function (nums) {
    let res = []
    nums.sort((a, b) => a - b);//排个序先
    let vis = new Array(nums.length).fill(0)
    let dfs = (arr) => {
        if (nums.length === arr.length) res.push(arr)
        for (let i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] === nums[i - 1] && vis[i - 1] === 0) continue//同层之前有重复元素，且没被访问过，说明是重复
            if (vis[i]) continue
            vis[i] = 1
            arr.push(nums[i])
            dfs(arr.slice())
            arr.pop()
            vis[i] = 0
        }
    }
    dfs([])
    return res
};
```



## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

### 做法一：

时间复杂度高，因为并没有剪枝，

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先从小打到排序
    let res = []
    let dfs = (arr, total) => {
        if (total === target) {
            arr.sort((a, b) => a - b)
            for (r of res) {
                if (r.toString() === arr.toString()) {//判断结果中是否有同样的答案
                    return
                }
            }
            return res.push(arr)
        }
        if (total > target) return
        for (let i = 0; i < candidates.length; i++) {
            arr.push(candidates[i])
            let t = total
            total += candidates[i]
            dfs(arr.slice(), total)
            arr.pop()
            total = t
        }
    }
    dfs([], 0)
    return res
};
```

### 更好做法：

<img src="https://camo.githubusercontent.com/c3ffef944bf3879f161e23ec5203d2ef2254277dd78e2d245e31a2380bb0ea5e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383136353734323833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先排序
    let res = []
    let dfs = (arr, start, total) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            arr.push(candidates[i])
            dfs(arr.slice(), i, total + candidates[i])//下一次就只从自己开始，因为前面的必然重复计算过了
            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。 

 示例 1:

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

### 思路：

跟上一题差不多，但是有重复元素。同层遍历不能重复，不同层可以重复。

做法一：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    let vis = new Array(candidates.length).fill(0)
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > 0 && candidates[i] === candidates[i - 1] && vis[i - 1] === 0) continue
            vis[i] = 1
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
            vis[i] = 0
        }
    }
    dfs([], 0, 0)
    return res
};
```

做法二：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] === candidates[i - 1]) continue //只看start后面的即可，不是从0开始
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

### 做法：

```js
var combinationSum3 = function (k, n) {
    let res = []
    let dfs = (arr, start, total) => {
        if (arr.length > k || total > n) return
        if (arr.length === k && total === n) {
            return res.push(arr)
        }
        for (let i = start; i < 10; i++) {
            arr.push(i)

            dfs(arr.slice(), i + 1, total + i)//避免重复直接从当前的下一个开始

            arr.pop()
        }
    }
    dfs([], 1, 0)
    return res
};
```





## [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

示例 1：

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 做法：

```js
var combine = function (n, k) {
    let res = []
    let dfs = (arr, start) => {
        if (arr.length === k) {
            return res.push(arr)
        }
        for (let i = start; i <= n; i++) {
            arr.push(i)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 1)
    return res
};
```



## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

**示例：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714svg.png" alt="img" style="zoom:50%;" />

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714_solutionsvg.png" alt="img" style="zoom:50%;" />

### 做法：

```js
var solveSudoku = function (board) {
    let check = (x, y, val) => {
        //该行列有重复元素
        for (let i = 0; i < 9; i++) {
            if (board[x][i] === val || board[i][y] === val) return true
        }
        let xx = x / 3 * 3
        let yy = y / 3 * 3
        //九宫格内是否重复
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[xx + i][yy + j] === val) return true
            }
        }
        return false
    }

    let dfs = (x, y) => {
        if (y === 9) {
            x++
            y = 0
            if (x === 9) return true
        }
        if (board[x][y] !== '.') return dfs(x, y + 1)
        for (let i = 1; i < 10; i++) {
            if (check(x, y, String(i))) continue  //遍历数字1-9是否重复
            board[x][y] = String(i)//给该位置赋值
            if (dfs(x, y + 1)) return true //能够解出数独 返回true
            board[x][y] = '.'//否则回溯
        }
        return false
    }
    dfs(0, 0)
    return board
};
```



## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/queens.jpg" alt="img" style="zoom:50%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

### 做法：

```js
var solveNQueens = function (n) {
    let grid = new Array(n).fill('.').map(() => new Array(n).fill('.')); // 初始化一个地图
    let res = []
    let check = (x, y) => {//检查该位置是否重复
        for (let i = 0; i < x; i++) {//判断之前已经放入过皇后的行
            for (let j = 0; j < n; j++) {
                // 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）
                // i + j === x + y是左下角      i - j === x - y是右下角
                if (grid[i][j] === 'Q' && (j === y || i + j === x + y || i - j === x - y)) {
                    return true;
                }
            }
        }
        return false;
    }
    let dfs = (t) => {
        if (t === n) {
            let ans = grid.slice(); // 拷贝一份，对输出做处理
            for (let i = 0; i < n; i++) {
                ans[i] = ans[i].join('');//将数组转为string
            }
            res.push(ans)//若皇后的数量等于n，说明是一种解决方案，放置到res中
            return
        }
        for (let i = 0; i < n; i++) {//第一行的每一列依次试一遍
            if (check(t, i)) continue;//重复直接判断下一列
            grid[t][i] = 'Q';
            dfs(t + 1);
            grid[t][i] = '.';
        }
    }
    dfs(0)
    return res
};
```



## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

### 思路：

<img src="https://camo.githubusercontent.com/c80ca562d26b469450d21d9b9056ea8bf146943866010d6aa9e48f2c7cc9f6a0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343134323130323339352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

```js
var partition = function (s) {
    let res = []
    let check = (str) => {//检查是否为回文串
        if (str === '') return true
        for (let i = 0; i < Math.floor(str.length / 2); i++) {
            if (str[i] !== str[str.length - 1 - i]) return false
        }
        return true
    }
    let dfs = (arr, start) => {//字符数组，起始位置
        if (start === s.length) {
            return res.push(arr)
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)//截取字符串
            if (check(str)) {//当前不是回文直接假如下一个字符，进入下一次循环
                arr.push(str)
                dfs(arr.slice(), i + 1)
                arr.pop()
            }
        }
    }
    dfs([], 0)
    return res
};
```





## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

### 解法：

和回文串的思路很相同，截取字符，判断当前字符是否符合标准，回溯

```js
var restoreIpAddresses = function (s) {
    let res = []
    let check = (str) => {//判断字符是否符合IP标准
        if (str.length > 1 && str[0] === '0') return false
        let val = parseInt(str)
        if (val <= 255 && val >= 0) return true
        return false
    }
    let dfs = (arr, start) => {
        if (arr.length === 4) {//数组长度为4进入判断
            if (start === s.length) {//若没有判断最后一个字符
                res.push(arr.join('.'))
            }
            return
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)
            if (!check(str)) continue//如果当前字符不满足ip地址，进入下一次循环
            arr.push(str)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```





## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

### 解法：

有左括号就选左括号，若右括号数量大于左括号，也能选

<img src="https://camo.githubusercontent.com/6d555b8550aa7cce132ecec4c0a1f4c6aae025840c4a6bb4fcfe6d0b3d31df6c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343135343433333533372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var generateParenthesis = function (n) {
    let res = []
    let dfs = (leftnum, rightnum, str) => {//给出剩余左右括号的数量
        if (str.length === n * 2) {
            return res.push(str)
        }
        if (leftnum > 0) dfs(leftnum - 1, rightnum, str + '(')//有左括号就选
        if (rightnum > leftnum) dfs(leftnum, rightnum - 1, str + ')')//若右括号大于左括号数量，也能选
    }
    dfs(n,n,'')
    return res
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

示例 1：

```
输出：low = 100, high = 300
输出：[123,234]
```


示例 2：

```
输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]
```

### 做法：

```js
var sequentialDigits = function (low, high) {
    let res = []
    for (i = 2; i <= 9; i++) {//题目给到数字的长度范围
        for (j = 1; j <= 10 - i; j++) {//顺序位的首位，比如两位数的话，首位只能在[1,8]取
            let shun = 0
            for (p = 0; p < i; p++) {
                shun = shun * 10 + j + p//每增加一位p，p都自加1，直到位数达到i，即进行够了i此循环
            }
            if (shun >= low) {
                if (shun <= high) {
                    res.push(shun);
                }
                else {
                    return res;
                }
            }
        }
    }
    return res
};
```



## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiraln.jpg" alt="img" style="zoom:67%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

### 自己做法：

```js
var generateMatrix = function (n) {
    let matrix = new Array(n).fill(1).map(() => new Array(n).fill(1))//生成二维数组
    let num = 1
    let top = 0, right = n, bottom = n, left = 0//生成对应边界
    let i = 0, j = 0
    if (n === 1) return matrix
    while (num <= n * n) {
        while (j < right && num <= n * n) {//填满上面一行
            matrix[i][j] = num
            j++
            num++
        }
        j--//对应的列要--，上面最后多加了
        top++//top界面往下移动
        i++//对应的行要往下移动一行
        while (i < bottom && num <= n * n) {
            matrix[i][j] = num
            i++
            num++
        }
        i--//对应的行要--，上面多加了
        right--//右边界往左移
        j--//列往左移
        while (j >= left && num <= n * n) {
            matrix[i][j] = num
            j--
            num++
        }
        j++//j最后多减了，加回来
        bottom--//下边界往上移
        i--//下一个需要填的行坐标
        while (i >= top && num <= n * n) {
            matrix[i][j] = num
            i--
            num++
        }
        i++//行多-了，+回来
        left++//右边界往右移动
        j++//下一元素的列坐标
    }
    return matrix
};
```

### 更简单做法：

```js
var generateMatrix = function (n) {
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0))
    let up = 0, down = n - 1, left = 0, right = n - 1, index = 1
    while (index <= n * n) {
        for (i = left; i <= right; i++) {
            res[up][i] = index++;
        }
        up++;
        for (i = up; i <= down; i++) {
            res[i][right] = index++;
        }
        right--;
        for (i = right; i >= left; i--) {
            res[down][i] = index++;
        }
        down--;
        for (i = down; i >= up; i--) {
            res[i][left] = index++;
        }
        left++;
    }
    return res;
};
```



## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiral1.jpg" alt="img" style="zoom:67%;" />

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

### 做法：

```js
var spiralOrder = function (matrix) {
    let res = []
    let m = matrix.length
    let n = matrix[0].length
    let left = 0, top = 0, right = n - 1, bottom = m - 1
    let num = m * n
    while (num >= 1) {
        for (i = left; i <= right && num >= 1; i++) {//必须判断是否遍历完所有的数字
            res.push(matrix[top][i])
            num--
        }
        top++
        for (i = top; i <= bottom && num >= 1; i++) {
            res.push(matrix[i][right])
            num--
        }
        right--
        for (i = right; i >= left && num >= 1; i--) {
            res.push(matrix[bottom][i])
            num--
        }
        console.log(res)
        bottom--
        for (i = bottom; i >= top && num >= 1; i--) {
            res.push(matrix[i][left])
            num--
        }
        left++
    }
    return res
};
```



## [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

示例 1：

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：

1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

类似于一笔画问题

### 做法：

```js
var uniquePathsIII = function (grid) {
    let sx, sy
    let cnt = 1
    for (i = 0; i < grid.length; i++) {
        for (j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {//设置起始位置
                sx = i
                sy = j
            }
            if (grid[i][j] === 0) cnt++//统计可走的空格数
        }
    }
    return dfs(sx, sy, grid, cnt)
};
let check = (sx, sy, grid) => {//检查新的起始位置是否合法
    if (sx < 0 || sx >= grid.length || sy < 0 || sy >= grid[0].length || grid[sx][sy] === -1) return false
    //判断起点位置是否超过下标范围，以及起始位置是否为障碍
    return true
}
let dfs = (sx, sy, grid, cnt) => {
    if (!check(sx, sy, grid)) return 0//首先检查下，假如不合格直接return 0
    if (grid[sx][sy] === 2) {//假如当前是终点，需要判断所有的空格是否走完
        return cnt > 0 ? 0 : 1//若cnt正好等于0，路径数+1
    }
    grid[sx][sy] = -1//将该路径设置为不可通行
    let res = 0//统计路径数
    res += dfs(sx - 1, sy, grid, cnt - 1)
    res += dfs(sx, sy - 1, grid, cnt - 1)
    res += dfs(sx + 1, sy, grid, cnt - 1)
    res += dfs(sx, sy + 1, grid, cnt - 1)
    grid[sx][sy] = 0//回溯过程，不影响后续dfs
    return res
}
```

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/inorder_1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    let res = []
    let dfs = (root) => {
        if (!root) return
        dfs(root.left)
        res.push(root.val)
        dfs(root.right)
    }
    dfs(root)
    return res
};
```

## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```js
示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]
```

### 自己做法：

```js
var letterCasePermutation = function (s) {
    let res = [];
    let arrays = s.split('');//转为数组 字符串不能用s[0]='A'更改某个位置的值
    let dfs = (i, array) => {
        if (i === array.length) {
            return res.push(array.join(''));
        }
        if (!isNaN(Number(array[i]))) dfs(i + 1, array.slice());//不是数字直接i+1
        else {
            if ('A' <= array[i] && array[i] <= 'Z') {
                array[i] = array[i].toLowerCase();//大写，则先转小写
            }
            dfs(i + 1, array.slice());//先将小写的递归
            array[i] = array[i].toUpperCase();//此时必是小写，转大写
            dfs(i + 1, array.slice());//递归
        }
    }
    dfs(0, arrays);
    return res;
};
```

### 做法：

```js
var letterCasePermutation = function (s) {
    let n = s.length
    let res = []
    let dfs = (t, str) => {
        if (t.length === n)
            return res.push(t)//若遍历完成，返回将结果存入res并return
        let ch = str[0]//得到当前第一个字符
        let nextstr = str.substr(1)//截取下一步dfs的str
        if (!isNaN(Number(ch))) {
            dfs(t + ch, nextstr)//若为数字直接t+ch，
        } else {
            let tmp = ch.toUpperCase()//将字符转为大写
            if (tmp === ch) ch = ch.toLowerCase()//若本身就是大写，转为小写
            dfs(t + ch, nextstr)
            dfs(t + tmp, nextstr)
        }
    }
    dfs('', s)
    return res
};
```



## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

```
示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```

### 做法：

```js
var getMaximumGold = function (grid) {
    let m = grid.length
    let n = grid[0].length
    let max = Number.MIN_VALUE
    for (i = 0; i < m; i++) {//每个点挨着遍历
        for (j = 0; j < n; j++) {
            max = max > dfs(i, j, grid) ? max : dfs(i, j, grid)
        }
    }
    return max
};
let check = (i, j, grid) => {//检查合格性
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0)
        return false
    return true
}
let dfs = (i, j, grid) => {
    if (!check(i, j, grid)) return 0
    let res1 = 0
    let res2 = 0
    let res3 = 0
    let res4 = 0
    let val = grid[i][j]
    let res = grid[i][j]
    grid[i][j] = 0
    res1 += dfs(i + 1, j, grid)//记录四个方向的值
    res2 += dfs(i - 1, j, grid)
    res3 += dfs(i, j + 1, grid)
    res4 += dfs(i,  j - 1, grid)
    grid[i][j] = val
    return res + Math.max(res1, res2, res3, res4)//自己的值加四个方向最大的结果作为返回值
}
```



## [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

### 自己做法（不对）：

```js
var permutation = function (S) {
    let res = []
    let n = S.length
    let pos = []
    for (i = 0; i < n; i++) {
        pos.push(i)
    }
    let dfs = (str, loc, i) => {
        let temp = [...pos]
        str += S[loc]//添加该字符
        pos.splice(i, 1)//该位置将不再参与计算
        if (pos.length === 0) {
            if (res.includes(str)) return ''
            return res.push(str)
        }
        for (let i in pos) {
            dfs(str, pos[i], i)
        }
        pos = temp
        return str//还原
    }
    for (let i in pos) {
        dfs('', pos[i], i)
    }
    return res
};
```

### 做法：（全排列直接回溯法）

```js
var permutation = function (S) {
  let res = new Set()
  let vis = []
  let dfs = (t) => {
    if (t.length === S.length) return res.add(t)
    for (let i = 0; i < S.length; i++) {
      if (vis[i]) continue
      vis[i] = true
      dfs(t + S[i])
      vis[i] = false
    }
  }
  dfs('')
  return [...res]
}
```



## [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/search1.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

### 自己做法：（部分测试用例超时）

```js
var findWords = function (board, words) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(board, i, j, '', words, res)
        }
    }
    return res
};
let check = (board, i, j) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === 'error') return false
    return true
}
let dfs = (board, i, j, word, words, res) => {
    if (words.length === res.length) return
    if (!check(board, i, j)) return
    let char = board[i][j]
    board[i][j] = 'error'
    word += char
    if (words.includes(word) && res.indexOf(word) < 0) {
        res.push(word)
    }
    dfs(board, i, j + 1, word, words, res)
    dfs(board, i, j - 1, word, words, res)
    dfs(board, i + 1, j, word, words, res)
    dfs(board, i - 1, j, word, words, res)

    board[i][j] = char
}
```

### 字典树+回溯：

- 判断是否找到了，通过传递节点的END来判断
- 判断是否重复访问，通过动态更改走过的网格点来判断，就不需要再定义一个`vis`数组了

```js
var findWords = function(grid, words) {
  // 存放最终结果集
  let res = []
  // 字典树节点
  class TrieNode {
    constructor(){
      this.end = false
      this.child = {}
    }
  }
  // 最终形成的字典树根节点
  let root = null
  let Trie = function(){
    root = new TrieNode()
  }
  // 建立字典树
  Trie.prototype.insert = (word) => {
    let cur = root
    for(let i=0;i<word.length;i++){
      if(!cur.child[word[i]]){
        cur.child[word[i]] = new TrieNode()
      }
      cur = cur.child[word[i]]
    }
    cur.end = true
  }
  // 创建根节点
  let trie = new Trie()
  // 进行建树操作
  for(let i=0;i<words.length;i++){
    trie.insert(words[i])
  }
  let dfs = (x,y,t,cur) => {
    if(cur.end){
      res.push(t)
      cur.end = false // 避免重复计算
    }
    // 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走
    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == '#' || !cur.child[grid[x][y]]) return
    let tmp = grid[x][y]
    grid[x][y] = '#'  // 走
    cur = cur.child[tmp]
    dfs(x+1,y,t+tmp,cur)  // 上下左右四个方向遍历
    dfs(x,y+1,t+tmp,cur)
    dfs(x-1,y,t+tmp,cur)
    dfs(x,y-1,t+tmp,cur)
    grid[x][y] = tmp // 回溯（还原）
  }
  // 对单词表进行全局搜索
  for(let i=0;i<grid.length;i++){
    for(let j=0;j<grid[0].length;j++){
      dfs(i,j,'',root)
    }
  }
  return res
};
```



## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/word2.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

### 自己做法：

```js
var exist = function (board, word) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(i, j, board, '', word, res)
            if (res.includes(word)) return true
        }
    }
    return false
};
let check = (i, j, board) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === '1') return false
    return true
}
let dfs = (i, j, board, str, word, res) => {
    if (!check(i, j, board)) return
    let char = board[i][j]
    if (char !== word[str.length]) return
    str += char
    board[i][j] = '1'
    if (str === word) {
        return res.push(str)
    }
    dfs(i, j + 1, board, str, word, res)
    dfs(i, j - 1, board, str, word, res)
    dfs(i + 1, j, board, str, word, res)
    dfs(i - 1, j, board, str, word, res)
    board[i][j] = char
}
```

### 官方解法:

```js
var exist = function (board, word) {
    let m = board.length;
    let n = board[0].length;
    let vis = new Array(m).fill(0).map(() => new Array(n).fill(0));
    let dfs = (x, y, k) => {
        if (x < 0 || x >= m || y < 0 || y >= n || word[k] !== board[x][y]) {
            return false;
        }
        if (k === word.length - 1) {
            return true;
        }
        board[x][y] = '';
        let res = dfs(x - 1, y, k + 1) || dfs(x + 1, y, k + 1)
            || dfs(x, y + 1, k + 1) || dfs(x, y - 1, k + 1);
        board[x][y] = word[k];
        return res;
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0)) return true;
        }
    }
    return false;
};
```



## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 `"3:25"` 。

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/binary_clock_samui_moon.jpg" alt="img" style="zoom: 20%;" />

### 解题思路

回溯算法，我的解法类似于全排列做法，将10个小灯泡进行排列组合，然后根据 `0` 和 `1` 来判断灯泡是否亮，如果亮了，加上对应二进制，然后将 `0-3`分给小时来计算，将 `4-9`分给分钟来计算，但是要考虑一下，就是可能会出现重复情况，于是用 `Set`数据结构维护一下就好了。

```js
var readBinaryWatch = function (turnedOn) {
    let vis = new Array(10).fill(0)
    let res = []
    let dfs = (index, onnum) => {
        if (onnum == 0) {
            hour = vis[6] * 1 + vis[7] * 2 + vis[8] * 4 + vis[9] * 8
            min = vis[0] * 1 + vis[1] * 2 + vis[2] * 4 + vis[3] * 8 + vis[4] * 16 + vis[5] * 32
            if (check(hour, min)) {
                let t = `${hour}:${min >= 10 ? min : '0' + min}`
                res.push(t)
            }
            return
        }
        for (let i = index; i <= 10 - onnum; i++) {//全排列问题，进行了去重操作，关键点在回溯 for循环。
            if (vis[i]) continue
            vis[i] = 1
            dfs(i + 1, onnum - 1)
            vis[i] = 0
        }
    }
    dfs(0,turnedOn)
    return res
};
let check = (hour, min) => {
    if (hour <= 11 && hour >= 0 && min <= 59 && min >= 0) return true
    return false
}
```



## [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

### 解法：

```js
var subsets = function (nums) {
    let res = []
    let dfs = (arr, start) => {
        res.push(arr)
        if (arr.length === nums.length) return
        for (let i = start; i < nums.length; i++) {
            arr.push(nums[i])
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```

### 解法二：

```js
var subsets = function (nums) {
    const res = [];
    res.push([]);
    for (let num of nums) {
        let temp = [];
        for (let i in res) {
            let t = res[i].slice();
            t.push(num);
            temp.push(t);
        }
        res.push(...temp);
    }
    return res;
};
```



## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### 解法：

<img src="https://camo.githubusercontent.com/789ba6dd32b800b4e042cf42ee2f72e2557e9f15b99c9fcafad3635b8d32d192/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383134323134313537322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var subsetsWithDup = function (nums) {
    let res = [];
    nums.sort((a, b) => a - b);
    let dfs = (t, start) => {
        res.push(t);
        for (let i = start; i < nums.length; i++) {
            // 同层重复，跳过
            if (i > start && nums[i - 1] == nums[i]) continue;
            t.push(nums[i]);
            dfs(t.slice(), i + 1);//t.slice()=[...t] 不带参数，浅拷贝，更改副本可能更改原变量的值
            t.pop();//保证同层循环，入口数组是同一个
        }
    }
    dfs([], 0);
    return res;
};
```



## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 做法：

```js
var permute = function (nums) {
    let res = []
    let vis = []
    let dfs = (arr) => {
        if (arr.length === nums.length) {
            return res.push(arr)
        }
        for (let i = 0; i < nums.length; i++) {
            if (vis[i]) continue
            vis[i] = true
            let temp = [...arr]
            arr.push(nums[i])
            dfs(arr)
            vis[i] = false//标志位复原
            arr = temp//arr数组复原
        }
    }
    dfs([]);
    return res;
};
```



## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

### 解题思路：

<img src="https://camo.githubusercontent.com/c2431469e0869a6fcac989fe483fa1d4de537d0513cbe0b976c25477763fdfd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383135303931323433302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

对于每一层而言，需要判断相邻元素是否相同，相同的就没必要走了。

与同一层的上一个选项 `nums[i - 1]` 相同，且 `nums[i - 1]`有意义（即索引 `>= 0`），且没有被使用过，那就跳过该选项。

因为 `nums[i - 1]`如果被使用过，它会被修剪掉，不是一个选项了，即便它和 `nums[i]`重复，`nums[i]`还是可以选的。

```js
var permuteUnique = function (nums) {
    let res = []
    nums.sort((a, b) => a - b);//排个序先
    let vis = new Array(nums.length).fill(0)
    let dfs = (arr) => {
        if (nums.length === arr.length) res.push(arr)
        for (let i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] === nums[i - 1] && vis[i - 1] === 0) continue//同层之前有重复元素，且没被访问过，说明是重复
            if (vis[i]) continue
            vis[i] = 1
            arr.push(nums[i])
            dfs(arr.slice())
            arr.pop()
            vis[i] = 0
        }
    }
    dfs([])
    return res
};
```



## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

### 做法一：

时间复杂度高，因为并没有剪枝，

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先从小打到排序
    let res = []
    let dfs = (arr, total) => {
        if (total === target) {
            arr.sort((a, b) => a - b)
            for (r of res) {
                if (r.toString() === arr.toString()) {//判断结果中是否有同样的答案
                    return
                }
            }
            return res.push(arr)
        }
        if (total > target) return
        for (let i = 0; i < candidates.length; i++) {
            arr.push(candidates[i])
            let t = total
            total += candidates[i]
            dfs(arr.slice(), total)
            arr.pop()
            total = t
        }
    }
    dfs([], 0)
    return res
};
```

### 更好做法：

<img src="https://camo.githubusercontent.com/c3ffef944bf3879f161e23ec5203d2ef2254277dd78e2d245e31a2380bb0ea5e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383136353734323833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先排序
    let res = []
    let dfs = (arr, start, total) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            arr.push(candidates[i])
            dfs(arr.slice(), i, total + candidates[i])//下一次就只从自己开始，因为前面的必然重复计算过了
            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。 

 示例 1:

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

### 思路：

跟上一题差不多，但是有重复元素。同层遍历不能重复，不同层可以重复。

做法一：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    let vis = new Array(candidates.length).fill(0)
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > 0 && candidates[i] === candidates[i - 1] && vis[i - 1] === 0) continue
            vis[i] = 1
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
            vis[i] = 0
        }
    }
    dfs([], 0, 0)
    return res
};
```

做法二：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] === candidates[i - 1]) continue //只看start后面的即可，不是从0开始
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

### 做法：

```js
var combinationSum3 = function (k, n) {
    let res = []
    let dfs = (arr, start, total) => {
        if (arr.length > k || total > n) return
        if (arr.length === k && total === n) {
            return res.push(arr)
        }
        for (let i = start; i < 10; i++) {
            arr.push(i)

            dfs(arr.slice(), i + 1, total + i)//避免重复直接从当前的下一个开始

            arr.pop()
        }
    }
    dfs([], 1, 0)
    return res
};
```





## [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

示例 1：

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 做法：

```js
var combine = function (n, k) {
    let res = []
    let dfs = (arr, start) => {
        if (arr.length === k) {
            return res.push(arr)
        }
        for (let i = start; i <= n; i++) {
            arr.push(i)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 1)
    return res
};
```



## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

**示例：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714svg.png" alt="img" style="zoom:50%;" />

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714_solutionsvg.png" alt="img" style="zoom:50%;" />

### 做法：

```js
var solveSudoku = function (board) {
    let check = (x, y, val) => {
        //该行列有重复元素
        for (let i = 0; i < 9; i++) {
            if (board[x][i] === val || board[i][y] === val) return true
        }
        let xx = x / 3 * 3
        let yy = y / 3 * 3
        //九宫格内是否重复
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[xx + i][yy + j] === val) return true
            }
        }
        return false
    }

    let dfs = (x, y) => {
        if (y === 9) {
            x++
            y = 0
            if (x === 9) return true
        }
        if (board[x][y] !== '.') return dfs(x, y + 1)
        for (let i = 1; i < 10; i++) {
            if (check(x, y, String(i))) continue  //遍历数字1-9是否重复
            board[x][y] = String(i)//给该位置赋值
            if (dfs(x, y + 1)) return true //能够解出数独 返回true
            board[x][y] = '.'//否则回溯
        }
        return false
    }
    dfs(0, 0)
    return board
};
```



## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/queens.jpg" alt="img" style="zoom:50%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

### 做法：

```js
var solveNQueens = function (n) {
    let grid = new Array(n).fill('.').map(() => new Array(n).fill('.')); // 初始化一个地图
    let res = []
    let check = (x, y) => {//检查该位置是否重复
        for (let i = 0; i < x; i++) {//判断之前已经放入过皇后的行
            for (let j = 0; j < n; j++) {
                // 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）
                // i + j === x + y是左下角      i - j === x - y是右下角
                if (grid[i][j] === 'Q' && (j === y || i + j === x + y || i - j === x - y)) {
                    return true;
                }
            }
        }
        return false;
    }
    let dfs = (t) => {
        if (t === n) {
            let ans = grid.slice(); // 拷贝一份，对输出做处理
            for (let i = 0; i < n; i++) {
                ans[i] = ans[i].join('');//将数组转为string
            }
            res.push(ans)//若皇后的数量等于n，说明是一种解决方案，放置到res中
            return
        }
        for (let i = 0; i < n; i++) {//第一行的每一列依次试一遍
            if (check(t, i)) continue;//重复直接判断下一列
            grid[t][i] = 'Q';
            dfs(t + 1);
            grid[t][i] = '.';
        }
    }
    dfs(0)
    return res
};
```



## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

### 思路：

<img src="https://camo.githubusercontent.com/c80ca562d26b469450d21d9b9056ea8bf146943866010d6aa9e48f2c7cc9f6a0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343134323130323339352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

```js
var partition = function (s) {
    let res = []
    let check = (str) => {//检查是否为回文串
        if (str === '') return true
        for (let i = 0; i < Math.floor(str.length / 2); i++) {
            if (str[i] !== str[str.length - 1 - i]) return false
        }
        return true
    }
    let dfs = (arr, start) => {//字符数组，起始位置
        if (start === s.length) {
            return res.push(arr)
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)//截取字符串
            if (check(str)) {//当前不是回文直接假如下一个字符，进入下一次循环
                arr.push(str)
                dfs(arr.slice(), i + 1)
                arr.pop()
            }
        }
    }
    dfs([], 0)
    return res
};
```





## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

### 解法：

和回文串的思路很相同，截取字符，判断当前字符是否符合标准，回溯

```js
var restoreIpAddresses = function (s) {
    let res = []
    let check = (str) => {//判断字符是否符合IP标准
        if (str.length > 1 && str[0] === '0') return false
        let val = parseInt(str)
        if (val <= 255 && val >= 0) return true
        return false
    }
    let dfs = (arr, start) => {
        if (arr.length === 4) {//数组长度为4进入判断
            if (start === s.length) {//若没有判断最后一个字符
                res.push(arr.join('.'))
            }
            return
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)
            if (!check(str)) continue//如果当前字符不满足ip地址，进入下一次循环
            arr.push(str)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```





## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

### 解法：

有左括号就选左括号，若右括号数量大于左括号，也能选

<img src="https://camo.githubusercontent.com/6d555b8550aa7cce132ecec4c0a1f4c6aae025840c4a6bb4fcfe6d0b3d31df6c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343135343433333533372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var generateParenthesis = function (n) {
    let res = []
    let dfs = (leftnum, rightnum, str) => {//给出剩余左右括号的数量
        if (str.length === n * 2) {
            return res.push(str)
        }
        if (leftnum > 0) dfs(leftnum - 1, rightnum, str + '(')//有左括号就选
        if (rightnum > leftnum) dfs(leftnum, rightnum - 1, str + ')')//若右括号大于左括号数量，也能选
    }
    dfs(n,n,'')
    return res
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======
## [1291. 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

示例 1：

```
输出：low = 100, high = 300
输出：[123,234]
```


示例 2：

```
输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]
```

### 做法：

```js
var sequentialDigits = function (low, high) {
    let res = []
    for (i = 2; i <= 9; i++) {//题目给到数字的长度范围
        for (j = 1; j <= 10 - i; j++) {//顺序位的首位，比如两位数的话，首位只能在[1,8]取
            let shun = 0
            for (p = 0; p < i; p++) {
                shun = shun * 10 + j + p//每增加一位p，p都自加1，直到位数达到i，即进行够了i此循环
            }
            if (shun >= low) {
                if (shun <= high) {
                    res.push(shun);
                }
                else {
                    return res;
                }
            }
        }
    }
    return res
};
```



## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiraln.jpg" alt="img" style="zoom:67%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

### 自己做法：

```js
var generateMatrix = function (n) {
    let matrix = new Array(n).fill(1).map(() => new Array(n).fill(1))//生成二维数组
    let num = 1
    let top = 0, right = n, bottom = n, left = 0//生成对应边界
    let i = 0, j = 0
    if (n === 1) return matrix
    while (num <= n * n) {
        while (j < right && num <= n * n) {//填满上面一行
            matrix[i][j] = num
            j++
            num++
        }
        j--//对应的列要--，上面最后多加了
        top++//top界面往下移动
        i++//对应的行要往下移动一行
        while (i < bottom && num <= n * n) {
            matrix[i][j] = num
            i++
            num++
        }
        i--//对应的行要--，上面多加了
        right--//右边界往左移
        j--//列往左移
        while (j >= left && num <= n * n) {
            matrix[i][j] = num
            j--
            num++
        }
        j++//j最后多减了，加回来
        bottom--//下边界往上移
        i--//下一个需要填的行坐标
        while (i >= top && num <= n * n) {
            matrix[i][j] = num
            i--
            num++
        }
        i++//行多-了，+回来
        left++//右边界往右移动
        j++//下一元素的列坐标
    }
    return matrix
};
```

### 更简单做法：

```js
var generateMatrix = function (n) {
    let res = new Array(n).fill(0).map(() => new Array(n).fill(0))
    let up = 0, down = n - 1, left = 0, right = n - 1, index = 1
    while (index <= n * n) {
        for (i = left; i <= right; i++) {
            res[up][i] = index++;
        }
        up++;
        for (i = up; i <= down; i++) {
            res[i][right] = index++;
        }
        right--;
        for (i = right; i >= left; i--) {
            res[down][i] = index++;
        }
        down--;
        for (i = down; i >= up; i--) {
            res[i][left] = index++;
        }
        left++;
    }
    return res;
};
```



## [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/spiral1.jpg" alt="img" style="zoom:67%;" />

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

### 做法：

```js
var spiralOrder = function (matrix) {
    let res = []
    let m = matrix.length
    let n = matrix[0].length
    let left = 0, top = 0, right = n - 1, bottom = m - 1
    let num = m * n
    while (num >= 1) {
        for (i = left; i <= right && num >= 1; i++) {//必须判断是否遍历完所有的数字
            res.push(matrix[top][i])
            num--
        }
        top++
        for (i = top; i <= bottom && num >= 1; i++) {
            res.push(matrix[i][right])
            num--
        }
        right--
        for (i = right; i >= left && num >= 1; i--) {
            res.push(matrix[bottom][i])
            num--
        }
        console.log(res)
        bottom--
        for (i = bottom; i >= top && num >= 1; i--) {
            res.push(matrix[i][left])
            num--
        }
        left++
    }
    return res
};
```



## [980. 不同路径 III](https://leetcode-cn.com/problems/unique-paths-iii/)

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

示例 1：

```
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：

1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

类似于一笔画问题

### 做法：

```js
var uniquePathsIII = function (grid) {
    let sx, sy
    let cnt = 1
    for (i = 0; i < grid.length; i++) {
        for (j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === 1) {//设置起始位置
                sx = i
                sy = j
            }
            if (grid[i][j] === 0) cnt++//统计可走的空格数
        }
    }
    return dfs(sx, sy, grid, cnt)
};
let check = (sx, sy, grid) => {//检查新的起始位置是否合法
    if (sx < 0 || sx >= grid.length || sy < 0 || sy >= grid[0].length || grid[sx][sy] === -1) return false
    //判断起点位置是否超过下标范围，以及起始位置是否为障碍
    return true
}
let dfs = (sx, sy, grid, cnt) => {
    if (!check(sx, sy, grid)) return 0//首先检查下，假如不合格直接return 0
    if (grid[sx][sy] === 2) {//假如当前是终点，需要判断所有的空格是否走完
        return cnt > 0 ? 0 : 1//若cnt正好等于0，路径数+1
    }
    grid[sx][sy] = -1//将该路径设置为不可通行
    let res = 0//统计路径数
    res += dfs(sx - 1, sy, grid, cnt - 1)
    res += dfs(sx, sy - 1, grid, cnt - 1)
    res += dfs(sx + 1, sy, grid, cnt - 1)
    res += dfs(sx, sy + 1, grid, cnt - 1)
    grid[sx][sy] = 0//回溯过程，不影响后续dfs
    return res
}
```

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/inorder_1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
    let res = []
    let dfs = (root) => {
        if (!root) return
        dfs(root.left)
        res.push(root.val)
        dfs(root.right)
    }
    dfs(root)
    return res
};
```

## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

给定一个字符串`S`，通过将字符串`S`中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

```js
示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]
```

### 自己做法：

```js
var letterCasePermutation = function (s) {
    let res = [];
    let arrays = s.split('');//转为数组 字符串不能用s[0]='A'更改某个位置的值
    let dfs = (i, array) => {
        if (i === array.length) {
            return res.push(array.join(''));
        }
        if (!isNaN(Number(array[i]))) dfs(i + 1, array.slice());//不是数字直接i+1
        else {
            if ('A' <= array[i] && array[i] <= 'Z') {
                array[i] = array[i].toLowerCase();//大写，则先转小写
            }
            dfs(i + 1, array.slice());//先将小写的递归
            array[i] = array[i].toUpperCase();//此时必是小写，转大写
            dfs(i + 1, array.slice());//递归
        }
    }
    dfs(0, arrays);
    return res;
};
```

### 做法：

```js
var letterCasePermutation = function (s) {
    let n = s.length
    let res = []
    let dfs = (t, str) => {
        if (t.length === n)
            return res.push(t)//若遍历完成，返回将结果存入res并return
        let ch = str[0]//得到当前第一个字符
        let nextstr = str.substr(1)//截取下一步dfs的str
        if (!isNaN(Number(ch))) {
            dfs(t + ch, nextstr)//若为数字直接t+ch，
        } else {
            let tmp = ch.toUpperCase()//将字符转为大写
            if (tmp === ch) ch = ch.toLowerCase()//若本身就是大写，转为小写
            dfs(t + ch, nextstr)
            dfs(t + tmp, nextstr)
        }
    }
    dfs('', s)
    return res
};
```



## [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。

```
示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。
```

### 做法：

```js
var getMaximumGold = function (grid) {
    let m = grid.length
    let n = grid[0].length
    let max = Number.MIN_VALUE
    for (i = 0; i < m; i++) {//每个点挨着遍历
        for (j = 0; j < n; j++) {
            max = max > dfs(i, j, grid) ? max : dfs(i, j, grid)
        }
    }
    return max
};
let check = (i, j, grid) => {//检查合格性
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0)
        return false
    return true
}
let dfs = (i, j, grid) => {
    if (!check(i, j, grid)) return 0
    let res1 = 0
    let res2 = 0
    let res3 = 0
    let res4 = 0
    let val = grid[i][j]
    let res = grid[i][j]
    grid[i][j] = 0
    res1 += dfs(i + 1, j, grid)//记录四个方向的值
    res2 += dfs(i - 1, j, grid)
    res3 += dfs(i, j + 1, grid)
    res4 += dfs(i,  j - 1, grid)
    grid[i][j] = val
    return res + Math.max(res1, res2, res3, res4)//自己的值加四个方向最大的结果作为返回值
}
```



## [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

### 自己做法（不对）：

```js
var permutation = function (S) {
    let res = []
    let n = S.length
    let pos = []
    for (i = 0; i < n; i++) {
        pos.push(i)
    }
    let dfs = (str, loc, i) => {
        let temp = [...pos]
        str += S[loc]//添加该字符
        pos.splice(i, 1)//该位置将不再参与计算
        if (pos.length === 0) {
            if (res.includes(str)) return ''
            return res.push(str)
        }
        for (let i in pos) {
            dfs(str, pos[i], i)
        }
        pos = temp
        return str//还原
    }
    for (let i in pos) {
        dfs('', pos[i], i)
    }
    return res
};
```

### 做法：（全排列直接回溯法）

```js
var permutation = function (S) {
  let res = new Set()
  let vis = []
  let dfs = (t) => {
    if (t.length === S.length) return res.add(t)
    for (let i = 0; i < S.length; i++) {
      if (vis[i]) continue
      vis[i] = true
      dfs(t + S[i])
      vis[i] = false
    }
  }
  dfs('')
  return [...res]
}
```



## [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/search1.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

### 自己做法：（部分测试用例超时）

```js
var findWords = function (board, words) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(board, i, j, '', words, res)
        }
    }
    return res
};
let check = (board, i, j) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === 'error') return false
    return true
}
let dfs = (board, i, j, word, words, res) => {
    if (words.length === res.length) return
    if (!check(board, i, j)) return
    let char = board[i][j]
    board[i][j] = 'error'
    word += char
    if (words.includes(word) && res.indexOf(word) < 0) {
        res.push(word)
    }
    dfs(board, i, j + 1, word, words, res)
    dfs(board, i, j - 1, word, words, res)
    dfs(board, i + 1, j, word, words, res)
    dfs(board, i - 1, j, word, words, res)

    board[i][j] = char
}
```

### 字典树+回溯：

- 判断是否找到了，通过传递节点的END来判断
- 判断是否重复访问，通过动态更改走过的网格点来判断，就不需要再定义一个`vis`数组了

```js
var findWords = function(grid, words) {
  // 存放最终结果集
  let res = []
  // 字典树节点
  class TrieNode {
    constructor(){
      this.end = false
      this.child = {}
    }
  }
  // 最终形成的字典树根节点
  let root = null
  let Trie = function(){
    root = new TrieNode()
  }
  // 建立字典树
  Trie.prototype.insert = (word) => {
    let cur = root
    for(let i=0;i<word.length;i++){
      if(!cur.child[word[i]]){
        cur.child[word[i]] = new TrieNode()
      }
      cur = cur.child[word[i]]
    }
    cur.end = true
  }
  // 创建根节点
  let trie = new Trie()
  // 进行建树操作
  for(let i=0;i<words.length;i++){
    trie.insert(words[i])
  }
  let dfs = (x,y,t,cur) => {
    if(cur.end){
      res.push(t)
      cur.end = false // 避免重复计算
    }
    // 剪枝条件：1.边界处理 2.下一步是否可走 3.下一步字典树是否可走
    if(x<0 || x>=grid.length || y<0 || y>=grid[0].length || grid[x][y] == '#' || !cur.child[grid[x][y]]) return
    let tmp = grid[x][y]
    grid[x][y] = '#'  // 走
    cur = cur.child[tmp]
    dfs(x+1,y,t+tmp,cur)  // 上下左右四个方向遍历
    dfs(x,y+1,t+tmp,cur)
    dfs(x-1,y,t+tmp,cur)
    dfs(x,y-1,t+tmp,cur)
    grid[x][y] = tmp // 回溯（还原）
  }
  // 对单词表进行全局搜索
  for(let i=0;i<grid.length;i++){
    for(let j=0;j<grid[0].length;j++){
      dfs(i,j,'',root)
    }
  }
  return res
};
```



## [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/word2.jpg" alt="img" style="zoom:67%;" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

### 自己做法：

```js
var exist = function (board, word) {
    let m = board.length
    let n = board[0].length
    let res = []
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            dfs(i, j, board, '', word, res)
            if (res.includes(word)) return true
        }
    }
    return false
};
let check = (i, j, board) => {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] === '1') return false
    return true
}
let dfs = (i, j, board, str, word, res) => {
    if (!check(i, j, board)) return
    let char = board[i][j]
    if (char !== word[str.length]) return
    str += char
    board[i][j] = '1'
    if (str === word) {
        return res.push(str)
    }
    dfs(i, j + 1, board, str, word, res)
    dfs(i, j - 1, board, str, word, res)
    dfs(i + 1, j, board, str, word, res)
    dfs(i - 1, j, board, str, word, res)
    board[i][j] = char
}
```

### 官方解法:

```js
var exist = function (board, word) {
    let m = board.length;
    let n = board[0].length;
    let vis = new Array(m).fill(0).map(() => new Array(n).fill(0));
    let dfs = (x, y, k) => {
        if (x < 0 || x >= m || y < 0 || y >= n || word[k] !== board[x][y]) {
            return false;
        }
        if (k === word.length - 1) {
            return true;
        }
        board[x][y] = '';
        let res = dfs(x - 1, y, k + 1) || dfs(x + 1, y, k + 1)
            || dfs(x, y + 1, k + 1) || dfs(x, y - 1, k + 1);
        board[x][y] = word[k];
        return res;
    }
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (dfs(i, j, 0)) return true;
        }
    }
    return false;
};
```



## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 `"3:25"` 。

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/binary_clock_samui_moon.jpg" alt="img" style="zoom: 20%;" />

### 解题思路

回溯算法，我的解法类似于全排列做法，将10个小灯泡进行排列组合，然后根据 `0` 和 `1` 来判断灯泡是否亮，如果亮了，加上对应二进制，然后将 `0-3`分给小时来计算，将 `4-9`分给分钟来计算，但是要考虑一下，就是可能会出现重复情况，于是用 `Set`数据结构维护一下就好了。

```js
var readBinaryWatch = function (turnedOn) {
    let vis = new Array(10).fill(0)
    let res = []
    let dfs = (index, onnum) => {
        if (onnum == 0) {
            hour = vis[6] * 1 + vis[7] * 2 + vis[8] * 4 + vis[9] * 8
            min = vis[0] * 1 + vis[1] * 2 + vis[2] * 4 + vis[3] * 8 + vis[4] * 16 + vis[5] * 32
            if (check(hour, min)) {
                let t = `${hour}:${min >= 10 ? min : '0' + min}`
                res.push(t)
            }
            return
        }
        for (let i = index; i <= 10 - onnum; i++) {//全排列问题，进行了去重操作，关键点在回溯 for循环。
            if (vis[i]) continue
            vis[i] = 1
            dfs(i + 1, onnum - 1)
            vis[i] = 0
        }
    }
    dfs(0,turnedOn)
    return res
};
let check = (hour, min) => {
    if (hour <= 11 && hour >= 0 && min <= 59 && min >= 0) return true
    return false
}
```



## [78. 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

### 解法：

```js
var subsets = function (nums) {
    let res = []
    let dfs = (arr, start) => {
        res.push(arr)
        if (arr.length === nums.length) return
        for (let i = start; i < nums.length; i++) {
            arr.push(nums[i])
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```

### 解法二：

```js
var subsets = function (nums) {
    const res = [];
    res.push([]);
    for (let num of nums) {
        let temp = [];
        for (let i in res) {
            let t = res[i].slice();
            t.push(num);
            temp.push(t);
        }
        res.push(...temp);
    }
    return res;
};
```



## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### 解法：

<img src="https://camo.githubusercontent.com/789ba6dd32b800b4e042cf42ee2f72e2557e9f15b99c9fcafad3635b8d32d192/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383134323134313537322e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:50%;" />

```js
var subsetsWithDup = function (nums) {
    let res = [];
    nums.sort((a, b) => a - b);
    let dfs = (t, start) => {
        res.push(t);
        for (let i = start; i < nums.length; i++) {
            // 同层重复，跳过
            if (i > start && nums[i - 1] == nums[i]) continue;
            t.push(nums[i]);
            dfs(t.slice(), i + 1);//t.slice()=[...t] 不带参数，浅拷贝，更改副本可能更改原变量的值
            t.pop();//保证同层循环，入口数组是同一个
        }
    }
    dfs([], 0);
    return res;
};
```



## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 做法：

```js
var permute = function (nums) {
    let res = []
    let vis = []
    let dfs = (arr) => {
        if (arr.length === nums.length) {
            return res.push(arr)
        }
        for (let i = 0; i < nums.length; i++) {
            if (vis[i]) continue
            vis[i] = true
            let temp = [...arr]
            arr.push(nums[i])
            dfs(arr)
            vis[i] = false//标志位复原
            arr = temp//arr数组复原
        }
    }
    dfs([]);
    return res;
};
```



## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

### 解题思路：

<img src="https://camo.githubusercontent.com/c2431469e0869a6fcac989fe483fa1d4de537d0513cbe0b976c25477763fdfd7/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383135303931323433302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

对于每一层而言，需要判断相邻元素是否相同，相同的就没必要走了。

与同一层的上一个选项 `nums[i - 1]` 相同，且 `nums[i - 1]`有意义（即索引 `>= 0`），且没有被使用过，那就跳过该选项。

因为 `nums[i - 1]`如果被使用过，它会被修剪掉，不是一个选项了，即便它和 `nums[i]`重复，`nums[i]`还是可以选的。

```js
var permuteUnique = function (nums) {
    let res = []
    nums.sort((a, b) => a - b);//排个序先
    let vis = new Array(nums.length).fill(0)
    let dfs = (arr) => {
        if (nums.length === arr.length) res.push(arr)
        for (let i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] === nums[i - 1] && vis[i - 1] === 0) continue//同层之前有重复元素，且没被访问过，说明是重复
            if (vis[i]) continue
            vis[i] = 1
            arr.push(nums[i])
            dfs(arr.slice())
            arr.pop()
            vis[i] = 0
        }
    }
    dfs([])
    return res
};
```



## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

### 做法一：

时间复杂度高，因为并没有剪枝，

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先从小打到排序
    let res = []
    let dfs = (arr, total) => {
        if (total === target) {
            arr.sort((a, b) => a - b)
            for (r of res) {
                if (r.toString() === arr.toString()) {//判断结果中是否有同样的答案
                    return
                }
            }
            return res.push(arr)
        }
        if (total > target) return
        for (let i = 0; i < candidates.length; i++) {
            arr.push(candidates[i])
            let t = total
            total += candidates[i]
            dfs(arr.slice(), total)
            arr.pop()
            total = t
        }
    }
    dfs([], 0)
    return res
};
```

### 更好做法：

<img src="https://camo.githubusercontent.com/c3ffef944bf3879f161e23ec5203d2ef2254277dd78e2d245e31a2380bb0ea5e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303931383136353734323833372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var combinationSum = function (candidates, target) {
    candidates.sort((a, b) => a - b)//先排序
    let res = []
    let dfs = (arr, start, total) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            arr.push(candidates[i])
            dfs(arr.slice(), i, total + candidates[i])//下一次就只从自己开始，因为前面的必然重复计算过了
            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。 

 示例 1:

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

### 思路：

跟上一题差不多，但是有重复元素。同层遍历不能重复，不同层可以重复。

做法一：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    let vis = new Array(candidates.length).fill(0)
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > 0 && candidates[i] === candidates[i - 1] && vis[i - 1] === 0) continue
            vis[i] = 1
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
            vis[i] = 0
        }
    }
    dfs([], 0, 0)
    return res
};
```

做法二：

```js
var combinationSum2 = function (candidates, target) {
    let res = []
    candidates.sort((a, b) => a - b)
    let dfs = (arr, total, start) => {
        if (total >= target) {
            if (total === target) {
                res.push(arr)
            }
            return
        }
        for (let i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] === candidates[i - 1]) continue //只看start后面的即可，不是从0开始
            arr.push(candidates[i])

            dfs(arr.slice(), total + candidates[i], i + 1)//这个地方一定要传数组具体内容arr.slice()，而不是arr

            arr.pop()
        }
    }
    dfs([], 0, 0)
    return res
};
```



## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

### 做法：

```js
var combinationSum3 = function (k, n) {
    let res = []
    let dfs = (arr, start, total) => {
        if (arr.length > k || total > n) return
        if (arr.length === k && total === n) {
            return res.push(arr)
        }
        for (let i = start; i < 10; i++) {
            arr.push(i)

            dfs(arr.slice(), i + 1, total + i)//避免重复直接从当前的下一个开始

            arr.pop()
        }
    }
    dfs([], 1, 0)
    return res
};
```





## [77. 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

示例 1：

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 做法：

```js
var combine = function (n, k) {
    let res = []
    let dfs = (arr, start) => {
        if (arr.length === k) {
            return res.push(arr)
        }
        for (let i = start; i <= n; i++) {
            arr.push(i)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 1)
    return res
};
```



## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

**示例：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714svg.png" alt="img" style="zoom:50%;" />

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/250px-sudoku-by-l2g-20050714_solutionsvg.png" alt="img" style="zoom:50%;" />

### 做法：

```js
var solveSudoku = function (board) {
    let check = (x, y, val) => {
        //该行列有重复元素
        for (let i = 0; i < 9; i++) {
            if (board[x][i] === val || board[i][y] === val) return true
        }
        let xx = x / 3 * 3
        let yy = y / 3 * 3
        //九宫格内是否重复
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[xx + i][yy + j] === val) return true
            }
        }
        return false
    }

    let dfs = (x, y) => {
        if (y === 9) {
            x++
            y = 0
            if (x === 9) return true
        }
        if (board[x][y] !== '.') return dfs(x, y + 1)
        for (let i = 1; i < 10; i++) {
            if (check(x, y, String(i))) continue  //遍历数字1-9是否重复
            board[x][y] = String(i)//给该位置赋值
            if (dfs(x, y + 1)) return true //能够解出数独 返回true
            board[x][y] = '.'//否则回溯
        }
        return false
    }
    dfs(0, 0)
    return board
};
```



## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

**示例 1：**

<img src="%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF.assets/queens.jpg" alt="img" style="zoom:50%;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

### 做法：

```js
var solveNQueens = function (n) {
    let grid = new Array(n).fill('.').map(() => new Array(n).fill('.')); // 初始化一个地图
    let res = []
    let check = (x, y) => {//检查该位置是否重复
        for (let i = 0; i < x; i++) {//判断之前已经放入过皇后的行
            for (let j = 0; j < n; j++) {
                // 判断同列 或者 同一斜线即可（不需要判断同行是因为一行一行放的，一定不同行）
                // i + j === x + y是左下角      i - j === x - y是右下角
                if (grid[i][j] === 'Q' && (j === y || i + j === x + y || i - j === x - y)) {
                    return true;
                }
            }
        }
        return false;
    }
    let dfs = (t) => {
        if (t === n) {
            let ans = grid.slice(); // 拷贝一份，对输出做处理
            for (let i = 0; i < n; i++) {
                ans[i] = ans[i].join('');//将数组转为string
            }
            res.push(ans)//若皇后的数量等于n，说明是一种解决方案，放置到res中
            return
        }
        for (let i = 0; i < n; i++) {//第一行的每一列依次试一遍
            if (check(t, i)) continue;//重复直接判断下一列
            grid[t][i] = 'Q';
            dfs(t + 1);
            grid[t][i] = '.';
        }
    }
    dfs(0)
    return res
};
```



## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

### 思路：

<img src="https://camo.githubusercontent.com/c80ca562d26b469450d21d9b9056ea8bf146943866010d6aa9e48f2c7cc9f6a0/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343134323130323339352e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom: 33%;" />

```js
var partition = function (s) {
    let res = []
    let check = (str) => {//检查是否为回文串
        if (str === '') return true
        for (let i = 0; i < Math.floor(str.length / 2); i++) {
            if (str[i] !== str[str.length - 1 - i]) return false
        }
        return true
    }
    let dfs = (arr, start) => {//字符数组，起始位置
        if (start === s.length) {
            return res.push(arr)
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)//截取字符串
            if (check(str)) {//当前不是回文直接假如下一个字符，进入下一次循环
                arr.push(str)
                dfs(arr.slice(), i + 1)
                arr.pop()
            }
        }
    }
    dfs([], 0)
    return res
};
```





## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

### 解法：

和回文串的思路很相同，截取字符，判断当前字符是否符合标准，回溯

```js
var restoreIpAddresses = function (s) {
    let res = []
    let check = (str) => {//判断字符是否符合IP标准
        if (str.length > 1 && str[0] === '0') return false
        let val = parseInt(str)
        if (val <= 255 && val >= 0) return true
        return false
    }
    let dfs = (arr, start) => {
        if (arr.length === 4) {//数组长度为4进入判断
            if (start === s.length) {//若没有判断最后一个字符
                res.push(arr.join('.'))
            }
            return
        }
        for (let i = start; i < s.length; i++) {
            let str = s.slice(start, i + 1)
            if (!check(str)) continue//如果当前字符不满足ip地址，进入下一次循环
            arr.push(str)
            dfs(arr.slice(), i + 1)
            arr.pop()
        }
    }
    dfs([], 0)
    return res
};
```





## [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

### 解法：

有左括号就选左括号，若右括号数量大于左括号，也能选

<img src="https://camo.githubusercontent.com/6d555b8550aa7cce132ecec4c0a1f4c6aae025840c4a6bb4fcfe6d0b3d31df6c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932343135343433333533372e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d6a51794f5463784f413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730237069635f63656e746572" alt="img" style="zoom:33%;" />

```js
var generateParenthesis = function (n) {
    let res = []
    let dfs = (leftnum, rightnum, str) => {//给出剩余左右括号的数量
        if (str.length === n * 2) {
            return res.push(str)
        }
        if (leftnum > 0) dfs(leftnum - 1, rightnum, str + '(')//有左括号就选
        if (rightnum > leftnum) dfs(leftnum, rightnum - 1, str + ')')//若右括号大于左括号数量，也能选
    }
    dfs(n,n,'')
    return res
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
