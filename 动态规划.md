<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD


## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

### 带记忆数组的递归

Fn = Fn-1 + Fn-2

```js
var climbStairs = function (n) {
    let m = new Array(n + 1).fill(0)
    return memo(n, m)
};

var memo = function (n, m) {
    if (m[n] > 0) return m[n]
    if (n === 1) {
        m.splice(n, 1, 1)
    }
    else if (n === 2) m.splice(n, 1, 2)//m[n]===2无法赋值
    else {
        m.splice(n, 1, memo(n - 1, m) + memo(n - 2, m))
    }
    return m[n]

}
```

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109221930518.png" alt="image-20211109221930518" style="zoom:67%;" />

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109222011021.png" alt="image-20211109222011021" style="zoom:67%;" />

```js
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```





## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

每个值存储当前可偷的最大值，然后遍历到某个数字，该数字+上上家的钱与上家的钱进行比较，确定自己家最大的钱

```js
var rob = function (nums) {
    let p = 0, q = 0;//p代表上上家最高值，q代表上家最高值
    for (num of nums) {
        if (num + p > q) {//上上家+自己大于上家，则更新
            t = p
            p = q
            q = t + num
        } else {//否则只说明自家和上家最大值必定相同
            p = q
        }
    }
    return q
};
```







## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

示例 1：

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

和上一题差不多，只是假如偷了第一家就不能偷最后一家

所以偷的范围变为0-n-2      1-n-1   比较这两个范围最大值即可

```js
var rob = function (nums) {
    n = nums.length
    if(n===1) return nums[0]//假如长度为0直接返回即可
    return Math.max(robfun(0, n - 1, nums), robfun(1, n, nums))//比较这两个范围最大值即可
};
var robfun = function (i, n, nums) {
    let p = 0, q = 0
    for (i; i < n; i++) {
        num = nums[i]
        if (nums[i] + p > q) {
            t = p
            p = q
            q = t + num
        }
        else p = q
    }
    return q
}
```



## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/max1grid.jpg" alt="img" style="zoom:67%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

### 暴力解法：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102905424.png" alt="image-20211111102905424" style="zoom:67%;" />

```js
var maximalSquare = function (matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return maxSide;
    }
    let rows = matrix.length
    let columns = matrix[0].length
    let maxSide = 0
    for (i = 0; i < rows; i++) {
        for (j = 0; j < columns; j++) {
            if (matrix[i][j] === '1') {
                maxSide = Math.max(maxSide, 1)
                sideRange = Math.min(rows - i, columns - j)//正方形，确认最大遍历范围
                for (k = 1; k < sideRange; k++) {
                    flag = true//判断是否范围内元素都为1
                    if (matrix[i + k][j + k] === '0') break//先判断下一行，下一列交叉位置是否为1 
                    for (m = 0; m < k; m++) {//再判断下一行下一列中间元素是否为1
                        if (matrix[i + m][j + k] === '0' || matrix[i + k][j + m] === '0') {
                            flag = false;//若不为1，标志位置为false
                            break;
                        }
                    }
                    if (flag) {
                        maxSide = Math.max(maxSide, k + 1)//若范围内符合条件，将当前长度与之前最大比较
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return maxSide * maxSide
};
```

### 动态规划：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102647352.png" alt="image-20211111102647352" style="zoom:67%;" />

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function (matrix) {
    if (!matrix || !matrix.length) return 0;
    let res = 0; // 设置最长边长变量
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (matrix[i][j] == 1) {
                // 对于(i > 0 && j > 0)情况，当前位置边长长度等于左，左上，上三个方向边长长度的最小值，然后加1
                (i > 0 && j > 0) && (matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i - 1][j - 1], matrix[i][j - 1]) + 1);
            }
            res = Math.max(res, matrix[i][j]); // 迭代求最长边长
        }
    }
    return res ** 2; // 返回边长*边长
};
```





## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 自己解法：

```js
var coinChange = function (coins, amount) {
    if (amount === 0) return 0
    let dp = new Array(amount + 1).fill(-1)
    for (i = 1; i <= amount; i++) {
        if (coins.indexOf(i) > -1) {//假如包含则直接置为1
            dp[i] = 1
        }
        else {//否则由另外两种构成，每种保存自身最小换零数
            min = Number.MAX_VALUE;
            for (add = 1; add <= Math.floor(i / 2); add++) {
                if (dp[add] !== -1 && dp[i - add] !== -1) {//假如某个数不可置换则不进行判断
                    min = dp[add] + dp[i - add] < min ? dp[add] + dp[i - add] : min
                }
            }
            if(min!==Number.MAX_VALUE) dp[i]=min//说明没有找到可换零数
        }
    }
    return dp[amount]
}
```

### 更好的解法：

参照示例1的题目，兑换11这个金额，目前有1，2，5三种硬币，先倒着推导，可以这么理解：假设凑齐11这个金额所需的最后一枚硬币是1，2，5其中的一个（也可以理解为兑换11所需要的硬币其中可能包含1，2，5中的一个），我们就分别看看包含哪个硬币的情况下，剩余金额使用的硬币数量最少，那么就会出现以下三种情况：

如果最后（包含）一枚是1，那么11-1=10 ，我们就需要知道兑换10所需的最少硬币数量dp[10]。
如果最后（包含）一枚是2，11-2=9，我们就需要知道兑换9所需的最少硬币数量dp[9]。
如果最后（包含）一枚是5，11-5=6，我们就需要知道兑换6所需的最少硬币数量dp[6]。

然后我们取出dp[10]，dp[9]，dp[6]三个值中的最小值，加上我们刚才拿出的那一枚硬币，就得出了兑换11的答案，这就是状态转移的过程。
那么问题来了，dp[10]，dp[9]，dp[6]这些值是怎么得到的呢？
其实就是重复上面的步骤，例如我们要知道dp[10]的值，也是分三种情况：10-1=9，10-2 = 8， 10-5= 5，以此类推。。。
这样如果知道了dp[0-10]的状态值，问题就解决了。我们采用自下而上的方式依次记录兑换0至11这些金额所需要的硬币最少组合值。

| 金额     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 最少硬币 | 0    | 1    | 1    | 2    | 2    | 1    | 2    | 2    | 3    | 3    | 2    | 3    |

求dp[1]的时候，很简单，结果肯定是1。
求dp[2]的时候，分别计算刚才提高的三种情况（1，2，5三种硬币），分别求2-1=1，2-2=0，2-5=-3（比当前金额大的硬币可以忽略）即dp[1],dp[0]中的最小值，然后+1就是dp[2]的结果。同理，dp[3],dp[4]…dp[11]都可以求出来了。

接下来，就看代码怎么写了，
第一步：如果需要记录这12个数，我们就需要一个长度为12的数组来记录每一个值的状态。
第二步：处理标记0-amount金额的状态，遍历coins里的所有硬币去计算出最少硬币数。
第三步：返回状态值，处理无法兑换的情况。

```js
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(amount + 1)//生成一个amount+1长度数组，值全为amount+1
    dp[0] = 0 //将0置为0
    for (i = 1; i <= amount; i++) {
        for (j = 0; j < coins.length; j++) {//用各种硬币判断情况
            if (i - coins[j] > -1) {//假如当前i-coins[j]说明，coins大了，不参与后面的判断
                dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]])//dp[i]==另一种方案+1枚硬币
            }
        }
    }
    return dp[amount] === amount + 1 ? -1 : dp[amount]//根据是否=amount值来置为-1
}
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot_maze.png" alt="img" style="zoom:67%;" />

```
输入：m = 3, n = 7
输出：28
```

### 自己做法:

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0)
    for (i = 0; i < m; i++) {
        dp[i] = new Array(n).fill(1)//生成二维数组给每个格子都设为1
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i - 1 > -1 && j - 1 > -1) {//考虑数组越界问题
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
            }
        }
    }
    return dp[m - 1][n - 1]
};
```



### 官方做法：

生成二维数组的方法，以及第一行列赋值为1

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//此种方法生成二维数组
    for (i = 0; i < m; i++) {//把第一行和第一列置为1，因为他们必然只有1种路径
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {
        dp[0][j] = 1
    }
    for (i = 1; i < m; i++) {//然后从第二行二列开始计算
        for (j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
        }
    }
    return dp[m - 1][n - 1]
};
```





## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

示例 1：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot1.jpg" alt="img" style="zoom:67%;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 自己做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    for (i = 0; i < m; i++) {//给第一列都赋值为1
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {//给第一行赋值为1
        dp[0][j] = 1
    }
    if (obstacleGrid[0].indexOf(1) > -1) {//假如第一行出现了第一个障碍，那后面肯定全为0
        j = obstacleGrid[0].indexOf(1)
        console.log(j)
        for (; j < n; j++) {
            dp[0][j] = 0
        }
    }
    let col = obstacleGrid.map((row) => row[0])//先获取第一列的元素
    if (col.indexOf(1) > -1) {//同理，第一列出现第一个障碍，后面都走不通，为0
        i = col.indexOf(1)
        console.log(i)
        for (; i < m; i++) {
            dp[i][0] = 0
        }
    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 1) {//假如当前为障碍，dp直接置为0
                dp[i][j] = 0
            }
            else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    return dp[m - 1][n - 1]
};
```

### 较好的做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    //初始化第一列，只要碰到一个1，那么后边都无法走到
    for (i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) { break; }
        dp[i][0] = 1;
    }
    //初始化第一行，只要碰到一个1，那么后边都无法走到
    for (j = 0; j < n; j++) {
        if (obstacleGrid[0][j] == 1) { break; }
        dp[0][j] = 1;

    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1]
};
```



## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 做法：

时间复杂度：o(n)    空间复杂度：o(1)

```js
var maxProfit = function (prices) {
    let min = Number.MAX_VALUE//存储遍历到当前位置的最小值
    let maxprofit = 0//存储得到的最大利润
    for (i = 0; i < prices.length; i++) {
        if (prices[i] < min) {//判断当前元素是否是最小的元素
            min = prices[i]//若是直接更新
        } else if (prices[i] - min > maxprofit) {//假如当前元素-最小元素大于了最大利润，更新
            maxprofit = prices[i] - min
        }
    }
    return maxprofit//返回最大利润
};
```





## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

### 自己做法：

```js
var maxProfit = function (prices) {
    let total = 0
    let max = 0
    let min = prices[0]//设第一个元素最小
    for (i = 1; i < prices.length; i++) {
        if (prices[i] - min < max) {//假如当前元素减去前面的最小元素不是最大值，说明此元素必然比前一个小
            min = prices[i]//所以将此元素更新为新的最小元素
            total += max//综合加上之前的最大差
            max = 0//将max重新置为0
        } else {//否则直接更新max值，因为进入这必然当前元素与前面的min差值最大
            let gap = prices[i] - min
            max = gap
        }
        if (i === prices.length - 1) {//为了满足[1,2,3,4,5]案例，若判断到了最后一种情况直接求和
            total += max
        }
    }
    return total
};
```

### 简单做法：

只要 比前一天高就卖然后再买

```js
var maxProfit = function (prices) {
    let prof = 0;
    for (i = 1; i < prices.length; i++) {
        prof += prices[i] > prices[i - 1] ? prices[i] - prices[i - 1] : 0;
    }
    return prof;
};
```



### 另一种思路：

状态 `dp[i][j] `表示：在下标为 `i` 的这一天，用户手上持股状态为 `j` 所获得的最大利润。

说明：

- `j` 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。
- 「用户手上不持股」不代表用户一定在下标为 `i` 的这一天把股票抛售了；

`dp[i][0] `怎样转移？

对于当前这天，不持股份的话，当然可以是前一天也没有持股份，即 `dp[i-1][0]` 还有可能就是昨天持股了，我今天把这股份卖了，那么就要加上今天卖的那份股份值，即 `dp[i-1][1] + prices[i]`

综上，得到状态方程：

```
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
```

`dp[i][1]` 怎样转移？

对于当前这天，如果持了股份的话，当天可以是前一天也持了股份，即 `dp[i-1][1]` 还有可能就是我今天才持股，同时注意，我们必须加上 `dp[i-1][0]`，因为我们可以**多笔交易**，即从当前这天持股，那么买入带来的收益即为 `dp[i-1][0]-prices[i]`

综上，得到状态方程：

```
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    let n = prices.length;
    if (n < 2) return 0; // 不足两天，肯定没收益
    let dp = new Array(n);
    for (let i = 0; i < n; i++) {
        dp[i] = new Array(2);
    }
    dp[0][0] = 0; // 第一天不持股
    dp[0][1] = -prices[0]; // 第一天持股，即买入
    for (let i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0]; // 最大收益，最后一天卖出股票的结果
};
```



## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 自己做法：回溯

```js
var translateNum = function (num) {
    let res = 0;
    let str = String(num);//将number变为string
    let dfs = (str) => {
        if (str === '') return res++;
        const n = str.length;
        for (let i = 0; i < n; i++) {
            let s = str.substring(0, i + 1);
            if (s.length > 1 && s[0] === '0') break;
            let temp = parseInt(s);
            if (0 <= temp && temp <= 25) {
                dfs(str.substring(i + 1))
            }else{
                break;
            }
        }
    }
    dfs(str);
    return res;
};
```

### 动态规划：

```js
var translateNum = function (num) {
    let p = 0, q = 0, r = 1;
    let str = String(num);
    for (let i = 0; i < str.length; i++) {
        p = q;
        q = r;
        r = 0;
        r += q;//当前的翻译数肯定f[i] = f[i-1]
        if (i === 0) continue;//若是第一个，不用与前面的比较
        let s = str.substring(i - 1, i + 1);
        if (s <= '25' && s >= '10') {//这种情况考虑了0为首位的情况
            r += p;//假如能与前一位也组成合法数字，则当前的翻译f[i] = f[i-1]+f[i-2];
        }
    }
    return r;
};
```

=======


## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

### 带记忆数组的递归

Fn = Fn-1 + Fn-2

```js
var climbStairs = function (n) {
    let m = new Array(n + 1).fill(0)
    return memo(n, m)
};

var memo = function (n, m) {
    if (m[n] > 0) return m[n]
    if (n === 1) {
        m.splice(n, 1, 1)
    }
    else if (n === 2) m.splice(n, 1, 2)//m[n]===2无法赋值
    else {
        m.splice(n, 1, memo(n - 1, m) + memo(n - 2, m))
    }
    return m[n]

}
```

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109221930518.png" alt="image-20211109221930518" style="zoom:67%;" />

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109222011021.png" alt="image-20211109222011021" style="zoom:67%;" />

```js
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```





## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

每个值存储当前可偷的最大值，然后遍历到某个数字，该数字+上上家的钱与上家的钱进行比较，确定自己家最大的钱

```js
var rob = function (nums) {
    let p = 0, q = 0;//p代表上上家最高值，q代表上家最高值
    for (num of nums) {
        if (num + p > q) {//上上家+自己大于上家，则更新
            t = p
            p = q
            q = t + num
        } else {//否则只说明自家和上家最大值必定相同
            p = q
        }
    }
    return q
};
```







## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

示例 1：

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

和上一题差不多，只是假如偷了第一家就不能偷最后一家

所以偷的范围变为0-n-2      1-n-1   比较这两个范围最大值即可

```js
var rob = function (nums) {
    n = nums.length
    if(n===1) return nums[0]//假如长度为0直接返回即可
    return Math.max(robfun(0, n - 1, nums), robfun(1, n, nums))//比较这两个范围最大值即可
};
var robfun = function (i, n, nums) {
    let p = 0, q = 0
    for (i; i < n; i++) {
        num = nums[i]
        if (nums[i] + p > q) {
            t = p
            p = q
            q = t + num
        }
        else p = q
    }
    return q
}
```



## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/max1grid.jpg" alt="img" style="zoom:67%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

### 暴力解法：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102905424.png" alt="image-20211111102905424" style="zoom:67%;" />

```js
var maximalSquare = function (matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return maxSide;
    }
    let rows = matrix.length
    let columns = matrix[0].length
    let maxSide = 0
    for (i = 0; i < rows; i++) {
        for (j = 0; j < columns; j++) {
            if (matrix[i][j] === '1') {
                maxSide = Math.max(maxSide, 1)
                sideRange = Math.min(rows - i, columns - j)//正方形，确认最大遍历范围
                for (k = 1; k < sideRange; k++) {
                    flag = true//判断是否范围内元素都为1
                    if (matrix[i + k][j + k] === '0') break//先判断下一行，下一列交叉位置是否为1 
                    for (m = 0; m < k; m++) {//再判断下一行下一列中间元素是否为1
                        if (matrix[i + m][j + k] === '0' || matrix[i + k][j + m] === '0') {
                            flag = false;//若不为1，标志位置为false
                            break;
                        }
                    }
                    if (flag) {
                        maxSide = Math.max(maxSide, k + 1)//若范围内符合条件，将当前长度与之前最大比较
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return maxSide * maxSide
};
```

### 动态规划：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102647352.png" alt="image-20211111102647352" style="zoom:67%;" />

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function (matrix) {
    if (!matrix || !matrix.length) return 0;
    let res = 0; // 设置最长边长变量
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (matrix[i][j] == 1) {
                // 对于(i > 0 && j > 0)情况，当前位置边长长度等于左，左上，上三个方向边长长度的最小值，然后加1
                (i > 0 && j > 0) && (matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i - 1][j - 1], matrix[i][j - 1]) + 1);
            }
            res = Math.max(res, matrix[i][j]); // 迭代求最长边长
        }
    }
    return res ** 2; // 返回边长*边长
};
```





## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 自己解法：

```js
var coinChange = function (coins, amount) {
    if (amount === 0) return 0
    let dp = new Array(amount + 1).fill(-1)
    for (i = 1; i <= amount; i++) {
        if (coins.indexOf(i) > -1) {//假如包含则直接置为1
            dp[i] = 1
        }
        else {//否则由另外两种构成，每种保存自身最小换零数
            min = Number.MAX_VALUE;
            for (add = 1; add <= Math.floor(i / 2); add++) {
                if (dp[add] !== -1 && dp[i - add] !== -1) {//假如某个数不可置换则不进行判断
                    min = dp[add] + dp[i - add] < min ? dp[add] + dp[i - add] : min
                }
            }
            if(min!==Number.MAX_VALUE) dp[i]=min//说明没有找到可换零数
        }
    }
    return dp[amount]
}
```

### 更好的解法：

参照示例1的题目，兑换11这个金额，目前有1，2，5三种硬币，先倒着推导，可以这么理解：假设凑齐11这个金额所需的最后一枚硬币是1，2，5其中的一个（也可以理解为兑换11所需要的硬币其中可能包含1，2，5中的一个），我们就分别看看包含哪个硬币的情况下，剩余金额使用的硬币数量最少，那么就会出现以下三种情况：

如果最后（包含）一枚是1，那么11-1=10 ，我们就需要知道兑换10所需的最少硬币数量dp[10]。
如果最后（包含）一枚是2，11-2=9，我们就需要知道兑换9所需的最少硬币数量dp[9]。
如果最后（包含）一枚是5，11-5=6，我们就需要知道兑换6所需的最少硬币数量dp[6]。

然后我们取出dp[10]，dp[9]，dp[6]三个值中的最小值，加上我们刚才拿出的那一枚硬币，就得出了兑换11的答案，这就是状态转移的过程。
那么问题来了，dp[10]，dp[9]，dp[6]这些值是怎么得到的呢？
其实就是重复上面的步骤，例如我们要知道dp[10]的值，也是分三种情况：10-1=9，10-2 = 8， 10-5= 5，以此类推。。。
这样如果知道了dp[0-10]的状态值，问题就解决了。我们采用自下而上的方式依次记录兑换0至11这些金额所需要的硬币最少组合值。

| 金额     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 最少硬币 | 0    | 1    | 1    | 2    | 2    | 1    | 2    | 2    | 3    | 3    | 2    | 3    |

求dp[1]的时候，很简单，结果肯定是1。
求dp[2]的时候，分别计算刚才提高的三种情况（1，2，5三种硬币），分别求2-1=1，2-2=0，2-5=-3（比当前金额大的硬币可以忽略）即dp[1],dp[0]中的最小值，然后+1就是dp[2]的结果。同理，dp[3],dp[4]…dp[11]都可以求出来了。

接下来，就看代码怎么写了，
第一步：如果需要记录这12个数，我们就需要一个长度为12的数组来记录每一个值的状态。
第二步：处理标记0-amount金额的状态，遍历coins里的所有硬币去计算出最少硬币数。
第三步：返回状态值，处理无法兑换的情况。

```js
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(amount + 1)//生成一个amount+1长度数组，值全为amount+1
    dp[0] = 0 //将0置为0
    for (i = 1; i <= amount; i++) {
        for (j = 0; j < coins.length; j++) {//用各种硬币判断情况
            if (i - coins[j] > -1) {//假如当前i-coins[j]说明，coins大了，不参与后面的判断
                dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]])//dp[i]==另一种方案+1枚硬币
            }
        }
    }
    return dp[amount] === amount + 1 ? -1 : dp[amount]//根据是否=amount值来置为-1
}
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot_maze.png" alt="img" style="zoom:67%;" />

```
输入：m = 3, n = 7
输出：28
```

### 自己做法:

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0)
    for (i = 0; i < m; i++) {
        dp[i] = new Array(n).fill(1)//生成二维数组给每个格子都设为1
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i - 1 > -1 && j - 1 > -1) {//考虑数组越界问题
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
            }
        }
    }
    return dp[m - 1][n - 1]
};
```



### 官方做法：

生成二维数组的方法，以及第一行列赋值为1

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//此种方法生成二维数组
    for (i = 0; i < m; i++) {//把第一行和第一列置为1，因为他们必然只有1种路径
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {
        dp[0][j] = 1
    }
    for (i = 1; i < m; i++) {//然后从第二行二列开始计算
        for (j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
        }
    }
    return dp[m - 1][n - 1]
};
```





## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

示例 1：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot1.jpg" alt="img" style="zoom:67%;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 自己做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    for (i = 0; i < m; i++) {//给第一列都赋值为1
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {//给第一行赋值为1
        dp[0][j] = 1
    }
    if (obstacleGrid[0].indexOf(1) > -1) {//假如第一行出现了第一个障碍，那后面肯定全为0
        j = obstacleGrid[0].indexOf(1)
        console.log(j)
        for (; j < n; j++) {
            dp[0][j] = 0
        }
    }
    let col = obstacleGrid.map((row) => row[0])//先获取第一列的元素
    if (col.indexOf(1) > -1) {//同理，第一列出现第一个障碍，后面都走不通，为0
        i = col.indexOf(1)
        console.log(i)
        for (; i < m; i++) {
            dp[i][0] = 0
        }
    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 1) {//假如当前为障碍，dp直接置为0
                dp[i][j] = 0
            }
            else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    return dp[m - 1][n - 1]
};
```

### 较好的做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    //初始化第一列，只要碰到一个1，那么后边都无法走到
    for (i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) { break; }
        dp[i][0] = 1;
    }
    //初始化第一行，只要碰到一个1，那么后边都无法走到
    for (j = 0; j < n; j++) {
        if (obstacleGrid[0][j] == 1) { break; }
        dp[0][j] = 1;

    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1]
};
```



## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 做法：

时间复杂度：o(n)    空间复杂度：o(1)

```js
var maxProfit = function (prices) {
    let min = Number.MAX_VALUE//存储遍历到当前位置的最小值
    let maxprofit = 0//存储得到的最大利润
    for (i = 0; i < prices.length; i++) {
        if (prices[i] < min) {//判断当前元素是否是最小的元素
            min = prices[i]//若是直接更新
        } else if (prices[i] - min > maxprofit) {//假如当前元素-最小元素大于了最大利润，更新
            maxprofit = prices[i] - min
        }
    }
    return maxprofit//返回最大利润
};
```





## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

### 自己做法：

```js
var maxProfit = function (prices) {
    let total = 0
    let max = 0
    let min = prices[0]//设第一个元素最小
    for (i = 1; i < prices.length; i++) {
        if (prices[i] - min < max) {//假如当前元素减去前面的最小元素不是最大值，说明此元素必然比前一个小
            min = prices[i]//所以将此元素更新为新的最小元素
            total += max//综合加上之前的最大差
            max = 0//将max重新置为0
        } else {//否则直接更新max值，因为进入这必然当前元素与前面的min差值最大
            let gap = prices[i] - min
            max = gap
        }
        if (i === prices.length - 1) {//为了满足[1,2,3,4,5]案例，若判断到了最后一种情况直接求和
            total += max
        }
    }
    return total
};
```

### 简单做法：

只要 比前一天高就卖然后再买

```js
var maxProfit = function (prices) {
    let prof = 0;
    for (i = 1; i < prices.length; i++) {
        prof += prices[i] > prices[i - 1] ? prices[i] - prices[i - 1] : 0;
    }
    return prof;
};
```



### 另一种思路：

状态 `dp[i][j] `表示：在下标为 `i` 的这一天，用户手上持股状态为 `j` 所获得的最大利润。

说明：

- `j` 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。
- 「用户手上不持股」不代表用户一定在下标为 `i` 的这一天把股票抛售了；

`dp[i][0] `怎样转移？

对于当前这天，不持股份的话，当然可以是前一天也没有持股份，即 `dp[i-1][0]` 还有可能就是昨天持股了，我今天把这股份卖了，那么就要加上今天卖的那份股份值，即 `dp[i-1][1] + prices[i]`

综上，得到状态方程：

```
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
```

`dp[i][1]` 怎样转移？

对于当前这天，如果持了股份的话，当天可以是前一天也持了股份，即 `dp[i-1][1]` 还有可能就是我今天才持股，同时注意，我们必须加上 `dp[i-1][0]`，因为我们可以**多笔交易**，即从当前这天持股，那么买入带来的收益即为 `dp[i-1][0]-prices[i]`

综上，得到状态方程：

```
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    let n = prices.length;
    if (n < 2) return 0; // 不足两天，肯定没收益
    let dp = new Array(n);
    for (let i = 0; i < n; i++) {
        dp[i] = new Array(2);
    }
    dp[0][0] = 0; // 第一天不持股
    dp[0][1] = -prices[0]; // 第一天持股，即买入
    for (let i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0]; // 最大收益，最后一天卖出股票的结果
};
```



## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 自己做法：回溯

```js
var translateNum = function (num) {
    let res = 0;
    let str = String(num);//将number变为string
    let dfs = (str) => {
        if (str === '') return res++;
        const n = str.length;
        for (let i = 0; i < n; i++) {
            let s = str.substring(0, i + 1);
            if (s.length > 1 && s[0] === '0') break;
            let temp = parseInt(s);
            if (0 <= temp && temp <= 25) {
                dfs(str.substring(i + 1))
            }else{
                break;
            }
        }
    }
    dfs(str);
    return res;
};
```

### 动态规划：

```js
var translateNum = function (num) {
    let p = 0, q = 0, r = 1;
    let str = String(num);
    for (let i = 0; i < str.length; i++) {
        p = q;
        q = r;
        r = 0;
        r += q;//当前的翻译数肯定f[i] = f[i-1]
        if (i === 0) continue;//若是第一个，不用与前面的比较
        let s = str.substring(i - 1, i + 1);
        if (s <= '25' && s >= '10') {//这种情况考虑了0为首位的情况
            r += p;//假如能与前一位也组成合法数字，则当前的翻译f[i] = f[i-1]+f[i-2];
        }
    }
    return r;
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======


## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

### 带记忆数组的递归

Fn = Fn-1 + Fn-2

```js
var climbStairs = function (n) {
    let m = new Array(n + 1).fill(0)
    return memo(n, m)
};

var memo = function (n, m) {
    if (m[n] > 0) return m[n]
    if (n === 1) {
        m.splice(n, 1, 1)
    }
    else if (n === 2) m.splice(n, 1, 2)//m[n]===2无法赋值
    else {
        m.splice(n, 1, memo(n - 1, m) + memo(n - 2, m))
    }
    return m[n]

}
```

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109221930518.png" alt="image-20211109221930518" style="zoom:67%;" />

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109222011021.png" alt="image-20211109222011021" style="zoom:67%;" />

```js
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```





## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

每个值存储当前可偷的最大值，然后遍历到某个数字，该数字+上上家的钱与上家的钱进行比较，确定自己家最大的钱

```js
var rob = function (nums) {
    let p = 0, q = 0;//p代表上上家最高值，q代表上家最高值
    for (num of nums) {
        if (num + p > q) {//上上家+自己大于上家，则更新
            t = p
            p = q
            q = t + num
        } else {//否则只说明自家和上家最大值必定相同
            p = q
        }
    }
    return q
};
```







## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

示例 1：

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

和上一题差不多，只是假如偷了第一家就不能偷最后一家

所以偷的范围变为0-n-2      1-n-1   比较这两个范围最大值即可

```js
var rob = function (nums) {
    n = nums.length
    if(n===1) return nums[0]//假如长度为0直接返回即可
    return Math.max(robfun(0, n - 1, nums), robfun(1, n, nums))//比较这两个范围最大值即可
};
var robfun = function (i, n, nums) {
    let p = 0, q = 0
    for (i; i < n; i++) {
        num = nums[i]
        if (nums[i] + p > q) {
            t = p
            p = q
            q = t + num
        }
        else p = q
    }
    return q
}
```



## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/max1grid.jpg" alt="img" style="zoom:67%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

### 暴力解法：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102905424.png" alt="image-20211111102905424" style="zoom:67%;" />

```js
var maximalSquare = function (matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return maxSide;
    }
    let rows = matrix.length
    let columns = matrix[0].length
    let maxSide = 0
    for (i = 0; i < rows; i++) {
        for (j = 0; j < columns; j++) {
            if (matrix[i][j] === '1') {
                maxSide = Math.max(maxSide, 1)
                sideRange = Math.min(rows - i, columns - j)//正方形，确认最大遍历范围
                for (k = 1; k < sideRange; k++) {
                    flag = true//判断是否范围内元素都为1
                    if (matrix[i + k][j + k] === '0') break//先判断下一行，下一列交叉位置是否为1 
                    for (m = 0; m < k; m++) {//再判断下一行下一列中间元素是否为1
                        if (matrix[i + m][j + k] === '0' || matrix[i + k][j + m] === '0') {
                            flag = false;//若不为1，标志位置为false
                            break;
                        }
                    }
                    if (flag) {
                        maxSide = Math.max(maxSide, k + 1)//若范围内符合条件，将当前长度与之前最大比较
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return maxSide * maxSide
};
```

### 动态规划：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102647352.png" alt="image-20211111102647352" style="zoom:67%;" />

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function (matrix) {
    if (!matrix || !matrix.length) return 0;
    let res = 0; // 设置最长边长变量
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (matrix[i][j] == 1) {
                // 对于(i > 0 && j > 0)情况，当前位置边长长度等于左，左上，上三个方向边长长度的最小值，然后加1
                (i > 0 && j > 0) && (matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i - 1][j - 1], matrix[i][j - 1]) + 1);
            }
            res = Math.max(res, matrix[i][j]); // 迭代求最长边长
        }
    }
    return res ** 2; // 返回边长*边长
};
```





## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 自己解法：

```js
var coinChange = function (coins, amount) {
    if (amount === 0) return 0
    let dp = new Array(amount + 1).fill(-1)
    for (i = 1; i <= amount; i++) {
        if (coins.indexOf(i) > -1) {//假如包含则直接置为1
            dp[i] = 1
        }
        else {//否则由另外两种构成，每种保存自身最小换零数
            min = Number.MAX_VALUE;
            for (add = 1; add <= Math.floor(i / 2); add++) {
                if (dp[add] !== -1 && dp[i - add] !== -1) {//假如某个数不可置换则不进行判断
                    min = dp[add] + dp[i - add] < min ? dp[add] + dp[i - add] : min
                }
            }
            if(min!==Number.MAX_VALUE) dp[i]=min//说明没有找到可换零数
        }
    }
    return dp[amount]
}
```

### 更好的解法：

参照示例1的题目，兑换11这个金额，目前有1，2，5三种硬币，先倒着推导，可以这么理解：假设凑齐11这个金额所需的最后一枚硬币是1，2，5其中的一个（也可以理解为兑换11所需要的硬币其中可能包含1，2，5中的一个），我们就分别看看包含哪个硬币的情况下，剩余金额使用的硬币数量最少，那么就会出现以下三种情况：

如果最后（包含）一枚是1，那么11-1=10 ，我们就需要知道兑换10所需的最少硬币数量dp[10]。
如果最后（包含）一枚是2，11-2=9，我们就需要知道兑换9所需的最少硬币数量dp[9]。
如果最后（包含）一枚是5，11-5=6，我们就需要知道兑换6所需的最少硬币数量dp[6]。

然后我们取出dp[10]，dp[9]，dp[6]三个值中的最小值，加上我们刚才拿出的那一枚硬币，就得出了兑换11的答案，这就是状态转移的过程。
那么问题来了，dp[10]，dp[9]，dp[6]这些值是怎么得到的呢？
其实就是重复上面的步骤，例如我们要知道dp[10]的值，也是分三种情况：10-1=9，10-2 = 8， 10-5= 5，以此类推。。。
这样如果知道了dp[0-10]的状态值，问题就解决了。我们采用自下而上的方式依次记录兑换0至11这些金额所需要的硬币最少组合值。

| 金额     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 最少硬币 | 0    | 1    | 1    | 2    | 2    | 1    | 2    | 2    | 3    | 3    | 2    | 3    |

求dp[1]的时候，很简单，结果肯定是1。
求dp[2]的时候，分别计算刚才提高的三种情况（1，2，5三种硬币），分别求2-1=1，2-2=0，2-5=-3（比当前金额大的硬币可以忽略）即dp[1],dp[0]中的最小值，然后+1就是dp[2]的结果。同理，dp[3],dp[4]…dp[11]都可以求出来了。

接下来，就看代码怎么写了，
第一步：如果需要记录这12个数，我们就需要一个长度为12的数组来记录每一个值的状态。
第二步：处理标记0-amount金额的状态，遍历coins里的所有硬币去计算出最少硬币数。
第三步：返回状态值，处理无法兑换的情况。

```js
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(amount + 1)//生成一个amount+1长度数组，值全为amount+1
    dp[0] = 0 //将0置为0
    for (i = 1; i <= amount; i++) {
        for (j = 0; j < coins.length; j++) {//用各种硬币判断情况
            if (i - coins[j] > -1) {//假如当前i-coins[j]说明，coins大了，不参与后面的判断
                dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]])//dp[i]==另一种方案+1枚硬币
            }
        }
    }
    return dp[amount] === amount + 1 ? -1 : dp[amount]//根据是否=amount值来置为-1
}
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot_maze.png" alt="img" style="zoom:67%;" />

```
输入：m = 3, n = 7
输出：28
```

### 自己做法:

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0)
    for (i = 0; i < m; i++) {
        dp[i] = new Array(n).fill(1)//生成二维数组给每个格子都设为1
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i - 1 > -1 && j - 1 > -1) {//考虑数组越界问题
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
            }
        }
    }
    return dp[m - 1][n - 1]
};
```



### 官方做法：

生成二维数组的方法，以及第一行列赋值为1

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//此种方法生成二维数组
    for (i = 0; i < m; i++) {//把第一行和第一列置为1，因为他们必然只有1种路径
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {
        dp[0][j] = 1
    }
    for (i = 1; i < m; i++) {//然后从第二行二列开始计算
        for (j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
        }
    }
    return dp[m - 1][n - 1]
};
```





## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

示例 1：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot1.jpg" alt="img" style="zoom:67%;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 自己做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    for (i = 0; i < m; i++) {//给第一列都赋值为1
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {//给第一行赋值为1
        dp[0][j] = 1
    }
    if (obstacleGrid[0].indexOf(1) > -1) {//假如第一行出现了第一个障碍，那后面肯定全为0
        j = obstacleGrid[0].indexOf(1)
        console.log(j)
        for (; j < n; j++) {
            dp[0][j] = 0
        }
    }
    let col = obstacleGrid.map((row) => row[0])//先获取第一列的元素
    if (col.indexOf(1) > -1) {//同理，第一列出现第一个障碍，后面都走不通，为0
        i = col.indexOf(1)
        console.log(i)
        for (; i < m; i++) {
            dp[i][0] = 0
        }
    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 1) {//假如当前为障碍，dp直接置为0
                dp[i][j] = 0
            }
            else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    return dp[m - 1][n - 1]
};
```

### 较好的做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    //初始化第一列，只要碰到一个1，那么后边都无法走到
    for (i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) { break; }
        dp[i][0] = 1;
    }
    //初始化第一行，只要碰到一个1，那么后边都无法走到
    for (j = 0; j < n; j++) {
        if (obstacleGrid[0][j] == 1) { break; }
        dp[0][j] = 1;

    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1]
};
```



## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 做法：

时间复杂度：o(n)    空间复杂度：o(1)

```js
var maxProfit = function (prices) {
    let min = Number.MAX_VALUE//存储遍历到当前位置的最小值
    let maxprofit = 0//存储得到的最大利润
    for (i = 0; i < prices.length; i++) {
        if (prices[i] < min) {//判断当前元素是否是最小的元素
            min = prices[i]//若是直接更新
        } else if (prices[i] - min > maxprofit) {//假如当前元素-最小元素大于了最大利润，更新
            maxprofit = prices[i] - min
        }
    }
    return maxprofit//返回最大利润
};
```





## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

### 自己做法：

```js
var maxProfit = function (prices) {
    let total = 0
    let max = 0
    let min = prices[0]//设第一个元素最小
    for (i = 1; i < prices.length; i++) {
        if (prices[i] - min < max) {//假如当前元素减去前面的最小元素不是最大值，说明此元素必然比前一个小
            min = prices[i]//所以将此元素更新为新的最小元素
            total += max//综合加上之前的最大差
            max = 0//将max重新置为0
        } else {//否则直接更新max值，因为进入这必然当前元素与前面的min差值最大
            let gap = prices[i] - min
            max = gap
        }
        if (i === prices.length - 1) {//为了满足[1,2,3,4,5]案例，若判断到了最后一种情况直接求和
            total += max
        }
    }
    return total
};
```

### 简单做法：

只要 比前一天高就卖然后再买

```js
var maxProfit = function (prices) {
    let prof = 0;
    for (i = 1; i < prices.length; i++) {
        prof += prices[i] > prices[i - 1] ? prices[i] - prices[i - 1] : 0;
    }
    return prof;
};
```



### 另一种思路：

状态 `dp[i][j] `表示：在下标为 `i` 的这一天，用户手上持股状态为 `j` 所获得的最大利润。

说明：

- `j` 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。
- 「用户手上不持股」不代表用户一定在下标为 `i` 的这一天把股票抛售了；

`dp[i][0] `怎样转移？

对于当前这天，不持股份的话，当然可以是前一天也没有持股份，即 `dp[i-1][0]` 还有可能就是昨天持股了，我今天把这股份卖了，那么就要加上今天卖的那份股份值，即 `dp[i-1][1] + prices[i]`

综上，得到状态方程：

```
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
```

`dp[i][1]` 怎样转移？

对于当前这天，如果持了股份的话，当天可以是前一天也持了股份，即 `dp[i-1][1]` 还有可能就是我今天才持股，同时注意，我们必须加上 `dp[i-1][0]`，因为我们可以**多笔交易**，即从当前这天持股，那么买入带来的收益即为 `dp[i-1][0]-prices[i]`

综上，得到状态方程：

```
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    let n = prices.length;
    if (n < 2) return 0; // 不足两天，肯定没收益
    let dp = new Array(n);
    for (let i = 0; i < n; i++) {
        dp[i] = new Array(2);
    }
    dp[0][0] = 0; // 第一天不持股
    dp[0][1] = -prices[0]; // 第一天持股，即买入
    for (let i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0]; // 最大收益，最后一天卖出股票的结果
};
```



## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 自己做法：回溯

```js
var translateNum = function (num) {
    let res = 0;
    let str = String(num);//将number变为string
    let dfs = (str) => {
        if (str === '') return res++;
        const n = str.length;
        for (let i = 0; i < n; i++) {
            let s = str.substring(0, i + 1);
            if (s.length > 1 && s[0] === '0') break;
            let temp = parseInt(s);
            if (0 <= temp && temp <= 25) {
                dfs(str.substring(i + 1))
            }else{
                break;
            }
        }
    }
    dfs(str);
    return res;
};
```

### 动态规划：

```js
var translateNum = function (num) {
    let p = 0, q = 0, r = 1;
    let str = String(num);
    for (let i = 0; i < str.length; i++) {
        p = q;
        q = r;
        r = 0;
        r += q;//当前的翻译数肯定f[i] = f[i-1]
        if (i === 0) continue;//若是第一个，不用与前面的比较
        let s = str.substring(i - 1, i + 1);
        if (s <= '25' && s >= '10') {//这种情况考虑了0为首位的情况
            r += p;//假如能与前一位也组成合法数字，则当前的翻译f[i] = f[i-1]+f[i-2];
        }
    }
    return r;
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
=======


## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

### 带记忆数组的递归

Fn = Fn-1 + Fn-2

```js
var climbStairs = function (n) {
    let m = new Array(n + 1).fill(0)
    return memo(n, m)
};

var memo = function (n, m) {
    if (m[n] > 0) return m[n]
    if (n === 1) {
        m.splice(n, 1, 1)
    }
    else if (n === 2) m.splice(n, 1, 2)//m[n]===2无法赋值
    else {
        m.splice(n, 1, memo(n - 1, m) + memo(n - 2, m))
    }
    return m[n]

}
```

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109221930518.png" alt="image-20211109221930518" style="zoom:67%;" />

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211109222011021.png" alt="image-20211109222011021" style="zoom:67%;" />

```js
var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    for (let i = 1; i <= n; ++i) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};

```





## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

每个值存储当前可偷的最大值，然后遍历到某个数字，该数字+上上家的钱与上家的钱进行比较，确定自己家最大的钱

```js
var rob = function (nums) {
    let p = 0, q = 0;//p代表上上家最高值，q代表上家最高值
    for (num of nums) {
        if (num + p > q) {//上上家+自己大于上家，则更新
            t = p
            p = q
            q = t + num
        } else {//否则只说明自家和上家最大值必定相同
            p = q
        }
    }
    return q
};
```







## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

示例 1：

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

### 思路：

和上一题差不多，只是假如偷了第一家就不能偷最后一家

所以偷的范围变为0-n-2      1-n-1   比较这两个范围最大值即可

```js
var rob = function (nums) {
    n = nums.length
    if(n===1) return nums[0]//假如长度为0直接返回即可
    return Math.max(robfun(0, n - 1, nums), robfun(1, n, nums))//比较这两个范围最大值即可
};
var robfun = function (i, n, nums) {
    let p = 0, q = 0
    for (i; i < n; i++) {
        num = nums[i]
        if (nums[i] + p > q) {
            t = p
            p = q
            q = t + num
        }
        else p = q
    }
    return q
}
```



## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/max1grid.jpg" alt="img" style="zoom:67%;" />

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

### 暴力解法：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102905424.png" alt="image-20211111102905424" style="zoom:67%;" />

```js
var maximalSquare = function (matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return maxSide;
    }
    let rows = matrix.length
    let columns = matrix[0].length
    let maxSide = 0
    for (i = 0; i < rows; i++) {
        for (j = 0; j < columns; j++) {
            if (matrix[i][j] === '1') {
                maxSide = Math.max(maxSide, 1)
                sideRange = Math.min(rows - i, columns - j)//正方形，确认最大遍历范围
                for (k = 1; k < sideRange; k++) {
                    flag = true//判断是否范围内元素都为1
                    if (matrix[i + k][j + k] === '0') break//先判断下一行，下一列交叉位置是否为1 
                    for (m = 0; m < k; m++) {//再判断下一行下一列中间元素是否为1
                        if (matrix[i + m][j + k] === '0' || matrix[i + k][j + m] === '0') {
                            flag = false;//若不为1，标志位置为false
                            break;
                        }
                    }
                    if (flag) {
                        maxSide = Math.max(maxSide, k + 1)//若范围内符合条件，将当前长度与之前最大比较
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return maxSide * maxSide
};
```

### 动态规划：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20211111102647352.png" alt="image-20211111102647352" style="zoom:67%;" />

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function (matrix) {
    if (!matrix || !matrix.length) return 0;
    let res = 0; // 设置最长边长变量
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (matrix[i][j] == 1) {
                // 对于(i > 0 && j > 0)情况，当前位置边长长度等于左，左上，上三个方向边长长度的最小值，然后加1
                (i > 0 && j > 0) && (matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i - 1][j - 1], matrix[i][j - 1]) + 1);
            }
            res = Math.max(res, matrix[i][j]); // 迭代求最长边长
        }
    }
    return res ** 2; // 返回边长*边长
};
```





## [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 自己解法：

```js
var coinChange = function (coins, amount) {
    if (amount === 0) return 0
    let dp = new Array(amount + 1).fill(-1)
    for (i = 1; i <= amount; i++) {
        if (coins.indexOf(i) > -1) {//假如包含则直接置为1
            dp[i] = 1
        }
        else {//否则由另外两种构成，每种保存自身最小换零数
            min = Number.MAX_VALUE;
            for (add = 1; add <= Math.floor(i / 2); add++) {
                if (dp[add] !== -1 && dp[i - add] !== -1) {//假如某个数不可置换则不进行判断
                    min = dp[add] + dp[i - add] < min ? dp[add] + dp[i - add] : min
                }
            }
            if(min!==Number.MAX_VALUE) dp[i]=min//说明没有找到可换零数
        }
    }
    return dp[amount]
}
```

### 更好的解法：

参照示例1的题目，兑换11这个金额，目前有1，2，5三种硬币，先倒着推导，可以这么理解：假设凑齐11这个金额所需的最后一枚硬币是1，2，5其中的一个（也可以理解为兑换11所需要的硬币其中可能包含1，2，5中的一个），我们就分别看看包含哪个硬币的情况下，剩余金额使用的硬币数量最少，那么就会出现以下三种情况：

如果最后（包含）一枚是1，那么11-1=10 ，我们就需要知道兑换10所需的最少硬币数量dp[10]。
如果最后（包含）一枚是2，11-2=9，我们就需要知道兑换9所需的最少硬币数量dp[9]。
如果最后（包含）一枚是5，11-5=6，我们就需要知道兑换6所需的最少硬币数量dp[6]。

然后我们取出dp[10]，dp[9]，dp[6]三个值中的最小值，加上我们刚才拿出的那一枚硬币，就得出了兑换11的答案，这就是状态转移的过程。
那么问题来了，dp[10]，dp[9]，dp[6]这些值是怎么得到的呢？
其实就是重复上面的步骤，例如我们要知道dp[10]的值，也是分三种情况：10-1=9，10-2 = 8， 10-5= 5，以此类推。。。
这样如果知道了dp[0-10]的状态值，问题就解决了。我们采用自下而上的方式依次记录兑换0至11这些金额所需要的硬币最少组合值。

| 金额     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 最少硬币 | 0    | 1    | 1    | 2    | 2    | 1    | 2    | 2    | 3    | 3    | 2    | 3    |

求dp[1]的时候，很简单，结果肯定是1。
求dp[2]的时候，分别计算刚才提高的三种情况（1，2，5三种硬币），分别求2-1=1，2-2=0，2-5=-3（比当前金额大的硬币可以忽略）即dp[1],dp[0]中的最小值，然后+1就是dp[2]的结果。同理，dp[3],dp[4]…dp[11]都可以求出来了。

接下来，就看代码怎么写了，
第一步：如果需要记录这12个数，我们就需要一个长度为12的数组来记录每一个值的状态。
第二步：处理标记0-amount金额的状态，遍历coins里的所有硬币去计算出最少硬币数。
第三步：返回状态值，处理无法兑换的情况。

```js
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(amount + 1)//生成一个amount+1长度数组，值全为amount+1
    dp[0] = 0 //将0置为0
    for (i = 1; i <= amount; i++) {
        for (j = 0; j < coins.length; j++) {//用各种硬币判断情况
            if (i - coins[j] > -1) {//假如当前i-coins[j]说明，coins大了，不参与后面的判断
                dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]])//dp[i]==另一种方案+1枚硬币
            }
        }
    }
    return dp[amount] === amount + 1 ? -1 : dp[amount]//根据是否=amount值来置为-1
}
```



## [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot_maze.png" alt="img" style="zoom:67%;" />

```
输入：m = 3, n = 7
输出：28
```

### 自己做法:

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0)
    for (i = 0; i < m; i++) {
        dp[i] = new Array(n).fill(1)//生成二维数组给每个格子都设为1
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (i - 1 > -1 && j - 1 > -1) {//考虑数组越界问题
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
            }
        }
    }
    return dp[m - 1][n - 1]
};
```



### 官方做法：

生成二维数组的方法，以及第一行列赋值为1

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//此种方法生成二维数组
    for (i = 0; i < m; i++) {//把第一行和第一列置为1，因为他们必然只有1种路径
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {
        dp[0][j] = 1
    }
    for (i = 1; i < m; i++) {//然后从第二行二列开始计算
        for (j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]//每个格子都是上面和左面格子路径的和
        }
    }
    return dp[m - 1][n - 1]
};
```





## [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

示例 1：

<img src="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/robot1.jpg" alt="img" style="zoom:67%;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 自己做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    for (i = 0; i < m; i++) {//给第一列都赋值为1
        dp[i][0] = 1
    }
    for (j = 0; j < n; j++) {//给第一行赋值为1
        dp[0][j] = 1
    }
    if (obstacleGrid[0].indexOf(1) > -1) {//假如第一行出现了第一个障碍，那后面肯定全为0
        j = obstacleGrid[0].indexOf(1)
        console.log(j)
        for (; j < n; j++) {
            dp[0][j] = 0
        }
    }
    let col = obstacleGrid.map((row) => row[0])//先获取第一列的元素
    if (col.indexOf(1) > -1) {//同理，第一列出现第一个障碍，后面都走不通，为0
        i = col.indexOf(1)
        console.log(i)
        for (; i < m; i++) {
            dp[i][0] = 0
        }
    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 1) {//假如当前为障碍，dp直接置为0
                dp[i][j] = 0
            }
            else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
            }
        }
    }
    return dp[m - 1][n - 1]
};
```

### 较好的做法：

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0))//生成二维数组
    //初始化第一列，只要碰到一个1，那么后边都无法走到
    for (i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) { break; }
        dp[i][0] = 1;
    }
    //初始化第一行，只要碰到一个1，那么后边都无法走到
    for (j = 0; j < n; j++) {
        if (obstacleGrid[0][j] == 1) { break; }
        dp[0][j] = 1;

    }
    for (i = 1; i < m; i++) {
        for (j = 1; j < n; j++) {
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1]
};
```



## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

### 做法：

时间复杂度：o(n)    空间复杂度：o(1)

```js
var maxProfit = function (prices) {
    let min = Number.MAX_VALUE//存储遍历到当前位置的最小值
    let maxprofit = 0//存储得到的最大利润
    for (i = 0; i < prices.length; i++) {
        if (prices[i] < min) {//判断当前元素是否是最小的元素
            min = prices[i]//若是直接更新
        } else if (prices[i] - min > maxprofit) {//假如当前元素-最小元素大于了最大利润，更新
            maxprofit = prices[i] - min
        }
    }
    return maxprofit//返回最大利润
};
```





## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:

```
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

### 自己做法：

```js
var maxProfit = function (prices) {
    let total = 0
    let max = 0
    let min = prices[0]//设第一个元素最小
    for (i = 1; i < prices.length; i++) {
        if (prices[i] - min < max) {//假如当前元素减去前面的最小元素不是最大值，说明此元素必然比前一个小
            min = prices[i]//所以将此元素更新为新的最小元素
            total += max//综合加上之前的最大差
            max = 0//将max重新置为0
        } else {//否则直接更新max值，因为进入这必然当前元素与前面的min差值最大
            let gap = prices[i] - min
            max = gap
        }
        if (i === prices.length - 1) {//为了满足[1,2,3,4,5]案例，若判断到了最后一种情况直接求和
            total += max
        }
    }
    return total
};
```

### 简单做法：

只要 比前一天高就卖然后再买

```js
var maxProfit = function (prices) {
    let prof = 0;
    for (i = 1; i < prices.length; i++) {
        prof += prices[i] > prices[i - 1] ? prices[i] - prices[i - 1] : 0;
    }
    return prof;
};
```



### 另一种思路：

状态 `dp[i][j] `表示：在下标为 `i` 的这一天，用户手上持股状态为 `j` 所获得的最大利润。

说明：

- `j` 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。
- 「用户手上不持股」不代表用户一定在下标为 `i` 的这一天把股票抛售了；

`dp[i][0] `怎样转移？

对于当前这天，不持股份的话，当然可以是前一天也没有持股份，即 `dp[i-1][0]` 还有可能就是昨天持股了，我今天把这股份卖了，那么就要加上今天卖的那份股份值，即 `dp[i-1][1] + prices[i]`

综上，得到状态方程：

```
dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
```

`dp[i][1]` 怎样转移？

对于当前这天，如果持了股份的话，当天可以是前一天也持了股份，即 `dp[i-1][1]` 还有可能就是我今天才持股，同时注意，我们必须加上 `dp[i-1][0]`，因为我们可以**多笔交易**，即从当前这天持股，那么买入带来的收益即为 `dp[i-1][0]-prices[i]`

综上，得到状态方程：

```
dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
```

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
    let n = prices.length;
    if (n < 2) return 0; // 不足两天，肯定没收益
    let dp = new Array(n);
    for (let i = 0; i < n; i++) {
        dp[i] = new Array(2);
    }
    dp[0][0] = 0; // 第一天不持股
    dp[0][1] = -prices[0]; // 第一天持股，即买入
    for (let i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[n - 1][0]; // 最大收益，最后一天卖出股票的结果
};
```



## [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 自己做法：回溯

```js
var translateNum = function (num) {
    let res = 0;
    let str = String(num);//将number变为string
    let dfs = (str) => {
        if (str === '') return res++;
        const n = str.length;
        for (let i = 0; i < n; i++) {
            let s = str.substring(0, i + 1);
            if (s.length > 1 && s[0] === '0') break;
            let temp = parseInt(s);
            if (0 <= temp && temp <= 25) {
                dfs(str.substring(i + 1))
            }else{
                break;
            }
        }
    }
    dfs(str);
    return res;
};
```

### 动态规划：

```js
var translateNum = function (num) {
    let p = 0, q = 0, r = 1;
    let str = String(num);
    for (let i = 0; i < str.length; i++) {
        p = q;
        q = r;
        r = 0;
        r += q;//当前的翻译数肯定f[i] = f[i-1]
        if (i === 0) continue;//若是第一个，不用与前面的比较
        let s = str.substring(i - 1, i + 1);
        if (s <= '25' && s >= '10') {//这种情况考虑了0为首位的情况
            r += p;//假如能与前一位也组成合法数字，则当前的翻译f[i] = f[i-1]+f[i-2];
        }
    }
    return r;
};
```

>>>>>>> 80016a86f0a17524ea5664f33d447f44cd769a36
